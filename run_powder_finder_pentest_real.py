"""
Real Penetration test for Powder Finder application running on localhost.
Tests actual endpoints and security vulnerabilities.
"""

import asyncio
import json
import os
import sys
from datetime import datetime
from unittest.mock import AsyncMock

import httpx

sys.path.insert(0, ".")

from weaver_ai.agents import BaseAgent
from weaver_ai.agents.publisher import ResultPublisher
from weaver_ai.memory import MemoryStrategy


class RealPowderFinderReconAgent(BaseAgent):
    """Reconnaissance agent for real powder finder application."""

    async def process(self, target: str) -> dict:
        """Scan the real powder finder application for entry points and data flows."""
        print(f"üîç Scanning REAL powder finder application: {target}")

        findings = {
            "endpoints": [],
            "inputs": [],
            "storage": [],
            "auth": [],
            "integrations": [],
            "discovered_apis": [],
            "status_codes": {},
            "headers_analysis": {},
            "cors_config": None,
            "rate_limits": None,
        }

        # Real endpoints to test
        test_endpoints = [
            # Health & Monitoring
            "/api/v1/health/",
            "/api/v1/health/detailed",
            "/api/v1/health/weather-collection",
            "/api/v1/health/liveness",
            "/api/v1/health/readiness",
            "/api/v1/monitoring/weather-collection-status",
            "/api/v1/monitoring/database-stats",
            "/api/v1/system/status",
            # Resort Endpoints
            "/api/v1/resorts/",
            "/api/v1/resorts/with-weather",
            "/api/v1/resorts/search/vail",
            "/api/v1/resorts/nearby?lat=39.6403&lon=-106.3742&radius=50",
            "/api/v1/resorts/all/unique",
            "/api/v1/resorts/1",
            # Season Endpoints
            "/api/v1/season/resorts/1/season",
            "/api/v1/season/resorts/open",
            # Weather Endpoints
            "/api/v1/weather/current/1",
            "/api/v1/weather/forecast/1",
            "/api/v1/weather/historical/1",
            "/api/v1/weather/snowfall/1",
            # Prediction Endpoints
            "/api/v1/predictions/",
            "/api/v1/predictions/1",
            "/api/v1/predictions/resort/1",
            # API Documentation
            "/api/docs",
            "/api/redoc",
            "/api/openapi.json",
            # Frontend Pages
            "/",
            "/dashboard",
            "/dashboard-enhanced",
            "/debug",
            "/test",
            "/working-dashboard",
            # Static Resources
            "/static/",
            "/static/css/",
            "/static/js/",
            "/static/images/",
        ]

        # Test actual endpoints
        async with httpx.AsyncClient(timeout=5.0) as client:
            for endpoint in test_endpoints:
                try:
                    url = f"{target}{endpoint}"
                    print(f"  Testing: {endpoint}")
                    response = await client.get(url, follow_redirects=False)

                    findings["endpoints"].append(
                        {
                            "path": endpoint,
                            "status": response.status_code,
                            "method": "GET",
                            "content_type": response.headers.get(
                                "content-type", "unknown"
                            ),
                        }
                    )

                    # Track status codes
                    status = str(response.status_code)
                    findings["status_codes"][status] = (
                        findings["status_codes"].get(status, 0) + 1
                    )

                    # Analyze headers for security
                    headers = dict(response.headers)
                    if endpoint == "/api/v1/health/":
                        findings["headers_analysis"] = {
                            "x_frame_options": headers.get("x-frame-options"),
                            "x_content_type_options": headers.get(
                                "x-content-type-options"
                            ),
                            "x_xss_protection": headers.get("x-xss-protection"),
                            "strict_transport_security": headers.get(
                                "strict-transport-security"
                            ),
                            "content_security_policy": headers.get(
                                "content-security-policy"
                            ),
                            "access_control_allow_origin": headers.get(
                                "access-control-allow-origin"
                            ),
                            "server": headers.get("server"),
                        }

                    # Check for CORS
                    if "access-control-allow-origin" in headers:
                        findings["cors_config"] = headers.get(
                            "access-control-allow-origin"
                        )

                    # Identify input parameters from successful endpoints
                    if response.status_code == 200:
                        if "search" in endpoint:
                            findings["inputs"].append("search_query (path parameter)")
                        if "lat=" in endpoint or "lon=" in endpoint:
                            findings["inputs"].append(
                                "geolocation (lat/lon query params)"
                            )
                        if "radius=" in endpoint:
                            findings["inputs"].append("radius (query parameter)")
                        if "resort_id" in endpoint or "/resorts/" in endpoint:
                            findings["inputs"].append("resort_id (path parameter)")

                except httpx.TimeoutException:
                    findings["endpoints"].append(
                        {"path": endpoint, "status": "timeout", "method": "GET"}
                    )
                except httpx.RequestError as e:
                    findings["endpoints"].append(
                        {
                            "path": endpoint,
                            "status": f"error: {str(e)}",
                            "method": "GET",
                        }
                    )

        # Test POST endpoints
        post_endpoints = [
            ("/api/v1/weather/update-resort", {"resort_id": 1}),
            ("/api/v1/weather/update-all-resorts", {}),
            ("/api/v1/chat/", {"message": "test"}),
            ("/api/v1/chat/resort-recommendations", {"preferences": "powder"}),
        ]

        async with httpx.AsyncClient(timeout=5.0) as client:
            for endpoint, payload in post_endpoints:
                try:
                    url = f"{target}{endpoint}"
                    print(f"  Testing POST: {endpoint}")
                    response = await client.post(url, json=payload)

                    findings["endpoints"].append(
                        {
                            "path": endpoint,
                            "status": response.status_code,
                            "method": "POST",
                            "content_type": response.headers.get(
                                "content-type", "unknown"
                            ),
                            "accepts": "application/json",
                        }
                    )

                    if response.status_code in [200, 201]:
                        findings["inputs"].append(f"JSON payload for {endpoint}")

                except Exception as e:
                    findings["endpoints"].append(
                        {
                            "path": endpoint,
                            "status": f"error: {str(e)}",
                            "method": "POST",
                        }
                    )

        # Analyze findings for storage and integrations
        api_content = str(findings["endpoints"])
        if "weather" in api_content or "forecast" in api_content:
            findings["integrations"].append("Weather API integration")
        if "database" in api_content or "resort" in api_content:
            findings["storage"].append("Database (likely PostgreSQL/SQLite)")
        if "predictions" in api_content:
            findings["integrations"].append("ML/AI prediction service")
        if "chat" in api_content:
            findings["integrations"].append("Chat/LLM integration")

        # Check authentication
        if not findings["headers_analysis"].get("authorization"):
            findings["auth"].append("No authentication headers required (public API)")

        # Discovered API patterns
        findings["discovered_apis"] = [
            "RESTful API with /api/v1/ prefix",
            "Health monitoring endpoints",
            "Resort data management",
            "Weather data integration",
            "Prediction/ML endpoints",
            "Chat/AI capabilities",
            "Static file serving",
        ]

        return {
            "agent": "recon",
            "target": target,
            "findings": findings,
            "timestamp": datetime.now().isoformat(),
            "endpoints_tested": len(test_endpoints) + len(post_endpoints),
            "active_endpoints": len(
                [
                    e
                    for e in findings["endpoints"]
                    if isinstance(e.get("status"), int) and e["status"] < 500
                ]
            ),
        }


class RealPowderFinderVulnAnalyzer(BaseAgent):
    """Real vulnerability analysis for powder finder application."""

    async def process(self, recon_data: dict) -> dict:
        """Analyze real powder finder app for vulnerabilities."""
        print("üî¨ Analyzing REAL powder finder vulnerabilities...")

        vulnerabilities = {"critical": [], "high": [], "medium": [], "low": []}

        # Analyze actual findings
        endpoints = recon_data.get("endpoints", [])
        headers = recon_data.get("headers_analysis", {})
        cors = recon_data.get("cors_config")

        # Check for missing security headers
        if not headers.get("x_frame_options"):
            vulnerabilities["medium"].append(
                "Missing X-Frame-Options header (clickjacking risk)"
            )
        if not headers.get("x_content_type_options"):
            vulnerabilities["low"].append("Missing X-Content-Type-Options header")
        if not headers.get("x_xss_protection"):
            vulnerabilities["low"].append("Missing X-XSS-Protection header")
        if not headers.get("strict_transport_security"):
            vulnerabilities["medium"].append("Missing HSTS header (HTTPS not enforced)")
        if not headers.get("content_security_policy"):
            vulnerabilities["medium"].append("Missing Content-Security-Policy header")

        # Check CORS configuration
        if cors == "*":
            vulnerabilities["high"].append(
                "CORS allows all origins (*) - potential data theft"
            )

        # Check for exposed server info
        if headers.get("server"):
            vulnerabilities["low"].append(
                f"Server header exposes version: {headers['server']}"
            )

        # Analyze endpoints for potential issues
        for endpoint in endpoints:
            if isinstance(endpoint.get("status"), int):
                path = endpoint["path"]

                # SQL injection risks in search/filter endpoints
                if "search" in path and endpoint["status"] == 200:
                    vulnerabilities["high"].append(
                        f"Potential SQL injection in {path} (needs testing)"
                    )

                # IDOR in ID-based endpoints
                if "/resorts/" in path and any(c.isdigit() for c in path):
                    vulnerabilities["medium"].append(
                        f"Potential IDOR in {path} (sequential IDs)"
                    )

                # Debug endpoints exposed
                if "/debug" in path and endpoint["status"] == 200:
                    vulnerabilities["high"].append(f"Debug endpoint exposed: {path}")

                # Test endpoint exposed
                if "/test" in path and endpoint["status"] == 200:
                    vulnerabilities["medium"].append(
                        f"Test endpoint exposed in production: {path}"
                    )

                # API documentation exposed
                if "openapi.json" in path and endpoint["status"] == 200:
                    vulnerabilities["low"].append(
                        "API schema publicly exposed (information disclosure)"
                    )

                # Unauthenticated POST endpoints
                if endpoint["method"] == "POST" and endpoint.get("status") in [
                    200,
                    201,
                ]:
                    if "update" in path or "chat" in path:
                        vulnerabilities["high"].append(
                            f"Unauthenticated POST endpoint: {path}"
                        )

        # Check for rate limiting
        post_endpoints = [e for e in endpoints if e.get("method") == "POST"]
        if post_endpoints and not recon_data.get("rate_limits"):
            vulnerabilities["high"].append(
                "No rate limiting detected on POST endpoints"
            )

        # Check authentication
        auth = recon_data.get("auth", [])
        if "No authentication" in str(auth):
            vulnerabilities["critical"].append("API endpoints lack authentication")

        # Calculate risk score
        risk_score = (
            len(vulnerabilities["critical"]) * 40
            + len(vulnerabilities["high"]) * 25
            + len(vulnerabilities["medium"]) * 15
            + len(vulnerabilities["low"]) * 5
        )

        return {
            "agent": "vulnerability_analyzer",
            "vulnerabilities": vulnerabilities,
            "risk_score": min(100, risk_score),
            "timestamp": datetime.now().isoformat(),
            "total_issues": sum(len(v) for v in vulnerabilities.values()),
            "endpoints_analyzed": len(endpoints),
        }


class RealPowderFinderExploitTester(BaseAgent):
    """Test real exploits for powder finder vulnerabilities."""

    async def process(self, vulnerabilities: dict) -> dict:
        """Test exploits for identified vulnerabilities."""
        print("üí• Testing REAL powder finder exploits...")

        exploits = {}
        target = "http://localhost"

        # Test actual exploits
        async with httpx.AsyncClient(timeout=5.0) as client:

            # Test SQL injection in search
            if any("SQL injection" in v for v in vulnerabilities.get("high", [])):
                print("  Testing SQL injection...")
                payloads = [
                    "vail' OR '1'='1",
                    "vail'; DROP TABLE users--",
                    "vail' UNION SELECT * FROM information_schema.tables--",
                ]

                for payload in payloads:
                    try:
                        response = await client.get(
                            f"{target}/api/v1/resorts/search/{payload}"
                        )
                        exploits["sql_injection"] = {
                            "payload": payload,
                            "response_code": response.status_code,
                            "vulnerable": response.status_code == 500
                            or "error" in response.text.lower(),
                            "impact": "Database access if vulnerable",
                            "mitigation": "Use parameterized queries",
                        }
                        if response.status_code == 500:
                            break
                    except Exception as e:
                        exploits["sql_injection"] = {
                            "payload": payload,
                            "error": str(e),
                            "vulnerable": "error" in str(e).lower(),
                        }

            # Test IDOR
            print("  Testing IDOR...")
            try:
                # Try accessing different resort IDs
                valid_response = await client.get(f"{target}/api/v1/resorts/1")
                invalid_response = await client.get(f"{target}/api/v1/resorts/99999")

                exploits["idor"] = {
                    "test": "Sequential ID enumeration",
                    "valid_id_status": valid_response.status_code,
                    "invalid_id_status": invalid_response.status_code,
                    "vulnerable": invalid_response.status_code != 404,
                    "impact": "Access to all resort data via ID enumeration",
                    "mitigation": "Use UUIDs or validate access permissions",
                }
            except Exception as e:
                exploits["idor"] = {"error": str(e)}

            # Test unauthenticated POST
            if any(
                "Unauthenticated POST" in v for v in vulnerabilities.get("high", [])
            ):
                print("  Testing unauthenticated POST...")
                try:
                    response = await client.post(
                        f"{target}/api/v1/weather/update-resort",
                        json={"resort_id": 1, "temperature": 999},
                    )
                    exploits["unauth_post"] = {
                        "endpoint": "/api/v1/weather/update-resort",
                        "payload": {"resort_id": 1, "temperature": 999},
                        "response_code": response.status_code,
                        "vulnerable": response.status_code in [200, 201],
                        "impact": "Unauthorized data modification",
                        "mitigation": "Implement authentication and authorization",
                    }
                except Exception as e:
                    exploits["unauth_post"] = {"error": str(e)}

            # Test XSS in chat endpoint
            print("  Testing XSS in chat...")
            try:
                xss_payload = "<script>alert('XSS')</script>"
                response = await client.post(
                    f"{target}/api/v1/chat/", json={"message": xss_payload}
                )

                exploits["xss_chat"] = {
                    "payload": xss_payload,
                    "response_code": response.status_code,
                    "reflected": xss_payload in response.text,
                    "vulnerable": xss_payload in response.text
                    and "<script>" in response.text,
                    "impact": "Cross-site scripting, session theft",
                    "mitigation": "Sanitize and encode user input",
                }
            except Exception as e:
                exploits["xss_chat"] = {"error": str(e)}

            # Test rate limiting
            print("  Testing rate limiting...")
            requests_sent = 0
            rate_limit_hit = False

            for i in range(20):
                try:
                    response = await client.get(f"{target}/api/v1/health/")
                    requests_sent += 1
                    if response.status_code == 429:
                        rate_limit_hit = True
                        break
                except Exception:
                    break

            exploits["rate_limiting"] = {
                "requests_sent": requests_sent,
                "rate_limit_hit": rate_limit_hit,
                "vulnerable": not rate_limit_hit and requests_sent >= 20,
                "impact": "DoS attacks, resource exhaustion",
                "mitigation": "Implement rate limiting",
            }

        # Calculate success rate
        successful_exploits = sum(
            1 for e in exploits.values() if isinstance(e, dict) and e.get("vulnerable")
        )
        total_exploits = len(exploits)
        success_rate = (
            (successful_exploits / total_exploits * 100) if total_exploits > 0 else 0
        )

        return {
            "agent": "exploit_tester",
            "exploits": exploits,
            "success_rate": f"{success_rate:.1f}%",
            "timestamp": datetime.now().isoformat(),
            "exploits_tested": total_exploits,
            "successful_exploits": successful_exploits,
        }


class RealPowderFinderReportGenerator(BaseAgent):
    """Generate security report for real powder finder application."""

    async def process(self, test_results: dict) -> dict:
        """Generate comprehensive security report from real test results."""
        print("üìä Generating REAL powder finder security report...")

        # Extract data from test results
        recon = test_results.get("recon", {})
        vulns = test_results.get("vulnerabilities", {})
        exploits = test_results.get("exploits", {})

        # Count vulnerabilities
        vuln_data = vulns.get("vulnerabilities", {})
        findings_summary = {
            "critical": len(vuln_data.get("critical", [])),
            "high": len(vuln_data.get("high", [])),
            "medium": len(vuln_data.get("medium", [])),
            "low": len(vuln_data.get("low", [])),
            "total": sum(len(v) for v in vuln_data.values()),
        }

        # Determine risk level
        if findings_summary["critical"] > 0:
            risk_level = "CRITICAL"
        elif findings_summary["high"] > 2:
            risk_level = "HIGH"
        elif findings_summary["medium"] > 3:
            risk_level = "MEDIUM"
        else:
            risk_level = "LOW"

        # Build top risks list
        top_risks = []
        for level in ["critical", "high", "medium"]:
            for risk in vuln_data.get(level, [])[:2]:  # Top 2 from each level
                top_risks.append(risk)

        # Build immediate actions based on actual findings
        immediate_actions = []

        if findings_summary["critical"] > 0:
            immediate_actions.append(
                "Implement authentication on all API endpoints immediately"
            )

        if any("SQL injection" in str(v) for v in vuln_data.get("high", [])):
            immediate_actions.append(
                "Audit and fix all database queries for SQL injection"
            )

        if any("Unauthenticated POST" in str(v) for v in vuln_data.get("high", [])):
            immediate_actions.append("Add authentication to all POST endpoints")

        if any("rate limiting" in str(v).lower() for v in vuln_data.get("high", [])):
            immediate_actions.append("Implement rate limiting on all endpoints")

        if any("Debug endpoint" in str(v) for v in vuln_data.get("high", [])):
            immediate_actions.append("Remove or protect debug endpoints")

        if any("CORS" in str(v) for v in vuln_data.get("high", [])):
            immediate_actions.append("Restrict CORS to specific trusted origins")

        # Add security headers recommendations
        header_issues = [
            v
            for v in vuln_data.get("medium", []) + vuln_data.get("low", [])
            if "header" in v.lower()
        ]
        if header_issues:
            immediate_actions.append(
                "Implement security headers (CSP, X-Frame-Options, etc.)"
            )

        report = {
            "executive_summary": f"""
                Security assessment of the Powder Finder application at {recon.get('target', 'localhost')}
                revealed {findings_summary['total']} security issues requiring attention.
                {findings_summary['critical']} critical and {findings_summary['high']} high-severity
                vulnerabilities pose immediate risk to data security and system integrity.
                The application currently has a {risk_level} risk profile.

                Tested {recon.get('endpoints_tested', 0)} endpoints with {recon.get('active_endpoints', 0)}
                responding successfully. {exploits.get('exploits', {}).get('successful_exploits', 0)}
                exploits were successfully demonstrated.
            """,
            "risk_level": risk_level,
            "findings_summary": findings_summary,
            "top_risks": (
                top_risks[:5] if top_risks else ["No critical risks identified"]
            ),
            "immediate_actions": (
                immediate_actions[:5] if immediate_actions else ["Continue monitoring"]
            ),
            "endpoints_tested": recon.get("endpoints_tested", 0),
            "active_endpoints": recon.get("active_endpoints", 0),
            "exploit_success_rate": exploits.get("exploits", {}).get(
                "success_rate", "0%"
            ),
            "detailed_vulnerabilities": vuln_data,
            "exploitation_results": exploits.get("exploits", {}),
            "remediation_timeline": {
                "immediate": immediate_actions[:2] if immediate_actions else [],
                "24_hours": (
                    ["Complete security audit", "Deploy WAF rules"]
                    if findings_summary["critical"] > 0
                    else []
                ),
                "1_week": [
                    "Fix all critical vulnerabilities",
                    "Implement authentication",
                ],
                "1_month": [
                    "Address all high and medium vulnerabilities",
                    "Conduct retest",
                ],
            },
            "compliance_impact": (
                "Non-compliant with OWASP Top 10 security standards"
                if findings_summary["critical"] > 0
                else "Minor compliance gaps identified"
            ),
        }

        return {
            "agent": "report_generator",
            "report": report,
            "timestamp": datetime.now().isoformat(),
        }


class RealPowderFinderPenTestCoordinator:
    """Coordinator for real powder finder penetration testing."""

    def __init__(self, publisher: ResultPublisher):
        self.publisher = publisher
        self.agents = {}

    async def run_pentest(self, target: str) -> dict:
        """Run complete penetration test on real powder finder application."""
        print("\nüöÄ Starting REAL Powder Finder Penetration Test")
        print(f"   Target: {target}\n")

        results = {}
        start_time = datetime.now()

        # Phase 1: Reconnaissance
        print("=" * 50)
        print("PHASE 1: RECONNAISSANCE")
        print("=" * 50)
        recon_result = await self.agents["recon"].process(target)
        results["recon"] = recon_result

        # Publish recon results
        published_recon = await self.publisher.publish(
            agent_id="recon",
            data=recon_result,
            capabilities_required=["pentest.read"],
            workflow_id="real_powder_finder_pentest",
            tags={"phase": "recon", "target": target},
        )
        print(f"‚úì Published recon results: {published_recon.metadata.result_id}")
        print(f"  Endpoints tested: {recon_result.get('endpoints_tested', 0)}")
        print(f"  Active endpoints: {recon_result.get('active_endpoints', 0)}")

        # Phase 2: Vulnerability Analysis
        print("\n" + "=" * 50)
        print("PHASE 2: VULNERABILITY ANALYSIS")
        print("=" * 50)
        vuln_result = await self.agents["vuln_analyzer"].process(
            recon_result["findings"]
        )
        results["vulnerabilities"] = vuln_result

        # Publish vulnerability results
        published_vuln = await self.publisher.publish(
            agent_id="vuln_analyzer",
            data=vuln_result,
            capabilities_required=["pentest.read"],
            workflow_id="real_powder_finder_pentest",
            parent_result_id=published_recon.metadata.result_id,
            tags={
                "phase": "analysis",
                "risk_score": str(vuln_result.get("risk_score", 0)),
            },
        )
        print(
            f"‚úì Published vulnerability analysis: {published_vuln.metadata.result_id}"
        )
        print(f"  Total issues found: {vuln_result.get('total_issues', 0)}")
        print(f"  Risk score: {vuln_result.get('risk_score', 0)}/100")

        # Phase 3: Exploit Testing
        print("\n" + "=" * 50)
        print("PHASE 3: EXPLOIT TESTING")
        print("=" * 50)
        exploit_result = await self.agents["exploit_tester"].process(
            vuln_result["vulnerabilities"]
        )
        results["exploits"] = exploit_result

        # Publish exploit results
        published_exploit = await self.publisher.publish(
            agent_id="exploit_tester",
            data=exploit_result,
            capabilities_required=["pentest.read", "pentest.exploit"],
            workflow_id="real_powder_finder_pentest",
            parent_result_id=published_vuln.metadata.result_id,
            tags={
                "phase": "exploitation",
                "success_rate": exploit_result.get("success_rate", "0%"),
            },
        )
        print(f"‚úì Published exploit results: {published_exploit.metadata.result_id}")
        print(f"  Exploits tested: {exploit_result.get('exploits_tested', 0)}")
        print(f"  Successful exploits: {exploit_result.get('successful_exploits', 0)}")

        # Phase 4: Report Generation
        print("\n" + "=" * 50)
        print("PHASE 4: REPORT GENERATION")
        print("=" * 50)
        report_result = await self.agents["reporter"].process(results)
        results["report"] = report_result

        # Publish final report
        published_report = await self.publisher.publish(
            agent_id="reporter",
            data=report_result,
            capabilities_required=["pentest.read"],
            workflow_id="real_powder_finder_pentest",
            parent_result_id=published_exploit.metadata.result_id,
            tags={
                "phase": "reporting",
                "risk_level": report_result["report"].get("risk_level", "UNKNOWN"),
            },
        )
        print(f"‚úì Published final report: {published_report.metadata.result_id}")

        # Calculate performance metrics
        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()

        results["performance"] = {
            "total_time": duration,
            "phases_completed": 4,
            "results_published": 4,
        }

        print(f"\n‚úÖ Penetration test completed in {duration:.2f} seconds")

        return results


async def run_real_powder_finder_pentest():
    """Run the real powder finder penetration test."""

    print("\n" + "=" * 60)
    print("REAL POWDER FINDER SECURITY ASSESSMENT")
    print("=" * 60 + "\n")

    target = "http://localhost"

    print(f"Target: {target}")
    print("Mode: REAL application testing")
    print()

    # Create mock publisher
    publisher = ResultPublisher()
    publisher.redis = AsyncMock()
    publisher._connected = True

    # Configure mock Redis
    stored_results = {}

    async def mock_get(key):
        return stored_results.get(key)

    async def mock_setex(key, ttl, value):
        stored_results[key] = value
        return True

    publisher.redis.get = AsyncMock(side_effect=mock_get)
    publisher.redis.setex = AsyncMock(side_effect=mock_setex)
    publisher.redis.sadd = AsyncMock(return_value=1)
    publisher.redis.zadd = AsyncMock(return_value=1)
    publisher.redis.expire = AsyncMock(return_value=True)
    publisher.redis.smembers = AsyncMock(return_value=[])
    publisher.redis.zrevrange = AsyncMock(return_value=[])

    # Initialize coordinator
    coordinator = RealPowderFinderPenTestCoordinator(publisher)

    # Memory strategies
    standard_memory = MemoryStrategy(
        short_term_size=100,
        long_term_size=1000,
        short_term_ttl=3600,
        long_term_ttl=86400,
    )

    # Create and configure agents
    print("Initializing penetration test agents...")

    # Recon Agent
    coordinator.agents["recon"] = RealPowderFinderReconAgent(
        agent_id="real_powder_recon",
        memory_strategy=standard_memory,
    )
    coordinator.agents["recon"].memory = AsyncMock()

    # Vulnerability Analyzer
    coordinator.agents["vuln_analyzer"] = RealPowderFinderVulnAnalyzer(
        agent_id="real_powder_vuln",
        memory_strategy=standard_memory,
    )
    coordinator.agents["vuln_analyzer"].memory = AsyncMock()

    # Exploit Tester
    coordinator.agents["exploit_tester"] = RealPowderFinderExploitTester(
        agent_id="real_powder_exploit",
        memory_strategy=standard_memory,
    )
    coordinator.agents["exploit_tester"].memory = AsyncMock()

    # Report Generator
    coordinator.agents["reporter"] = RealPowderFinderReportGenerator(
        agent_id="real_powder_reporter",
        memory_strategy=standard_memory,
    )
    coordinator.agents["reporter"].memory = AsyncMock()

    print(f"‚úì Initialized {len(coordinator.agents)} specialized agents")

    # Run penetration test
    print("\n" + "=" * 60)
    print("STARTING REAL APPLICATION PENETRATION TEST")
    print("=" * 60)

    try:
        results = await coordinator.run_pentest(target)

        # Save results to file
        results_dir = "pentest-results"
        os.makedirs(results_dir, exist_ok=True)

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        result_file = f"{results_dir}/real_powder_finder_pentest_{timestamp}.json"

        # Convert results to JSON-serializable format
        def serialize_results(obj):
            if isinstance(obj, datetime):
                return obj.isoformat()
            elif hasattr(obj, "__dict__"):
                return str(obj)
            return obj

        with open(result_file, "w") as f:
            json.dump(results, f, indent=2, default=serialize_results)

        print(f"\n‚úì Results saved to: {result_file}")

        # Display report
        if "report" in results:
            report = results["report"]["report"]

            print("\n" + "=" * 60)
            print("REAL APPLICATION SECURITY ASSESSMENT REPORT")
            print("=" * 60 + "\n")

            print("EXECUTIVE SUMMARY:")
            print("-" * 40)
            if isinstance(report, dict):
                print(report.get("executive_summary", "No summary available"))

                print("\n\nRISK ASSESSMENT:")
                print("-" * 40)
                print(f"Overall Risk Level: {report.get('risk_level', 'UNKNOWN')}")

                if "findings_summary" in report:
                    print("\nVulnerability Counts:")
                    for level, count in report["findings_summary"].items():
                        if level != "total":
                            print(f"  ‚Ä¢ {level.upper()}: {count}")

                if "top_risks" in report:
                    print("\nTop Security Risks:")
                    for risk in report["top_risks"][:5]:
                        print(f"  ‚Ä¢ {risk}")

                if "immediate_actions" in report:
                    print("\nImmediate Actions Required:")
                    for action in report["immediate_actions"][:5]:
                        print(f"  ‚Ä¢ {action}")

                print("\nExploit Testing Results:")
                print(f"  ‚Ä¢ Success Rate: {report.get('exploit_success_rate', 'N/A')}")
                print(f"  ‚Ä¢ Endpoints Tested: {report.get('endpoints_tested', 0)}")
                print(f"  ‚Ä¢ Active Endpoints: {report.get('active_endpoints', 0)}")

            print("\n\nPERFORMANCE METRICS:")
            print("-" * 40)
            if "performance" in results:
                perf = results["performance"]
                print(f"  Total Time: {perf.get('total_time', 0):.2f} seconds")
                print(f"  Phases Completed: {perf.get('phases_completed', 0)}")
                print(f"  Results Published: {perf.get('results_published', 0)}")

            print("\n" + "=" * 60)
            print("REAL APPLICATION PENETRATION TEST COMPLETE")
            print("=" * 60)

            print("\n‚úÖ Real Powder Finder Security Assessment Complete")
            print(f"   ‚Ä¢ Target: {target}")
            print(f"   ‚Ä¢ Results: {result_file}")

        else:
            print("‚ùå Test did not complete successfully")

    except Exception as e:
        print(f"\n‚ùå Error during penetration test: {e}")
        import traceback

        traceback.print_exc()


if __name__ == "__main__":
    print("\n" + "=" * 60)
    print("REAL POWDER FINDER PENETRATION TEST LAUNCHER")
    print("=" * 60)

    print("\n‚ö†Ô∏è  IMPORTANT: This test will scan REAL endpoints on localhost")
    print("Make sure your Powder Finder application is running on http://localhost")
    print("\nStarting real application security test...\n")

    asyncio.run(run_real_powder_finder_pentest())
