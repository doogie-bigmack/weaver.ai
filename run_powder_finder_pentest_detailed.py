"""
Enhanced Penetration test with detailed attack reporting for Powder Finder application.
Provides comprehensive details about each attack including URLs, payloads, and responses.
"""

import asyncio
import json
import os
import sys
from datetime import datetime
from unittest.mock import AsyncMock

import httpx

sys.path.insert(0, ".")

from weaver_ai.agents import BaseAgent
from weaver_ai.agents.publisher import ResultPublisher
from weaver_ai.memory import MemoryStrategy


def generate_markdown_report(results, target, duration):
    """Generate a formatted markdown report from test results."""
    report = results.get("report", {}).get("report", {})
    recon = results.get("recon", {})
    vulns = results.get("vulnerabilities", {})
    exploits = results.get("exploits", {})

    markdown = f"""# Powder Finder Security Assessment Report

**Target**: {target}
**Date**: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
**Duration**: {duration:.2f} seconds

## Executive Summary

{report.get("executive_summary", "No summary available").strip()}

**Overall Risk Level**: **{report.get("risk_level", "UNKNOWN")}**

## Vulnerability Summary

| Severity | Count |
|----------|-------|
"""

    findings_summary = report.get("findings_summary", {})
    for level in ["critical", "high", "medium", "low"]:
        count = findings_summary.get(level, 0)
        emoji = (
            "üî¥"
            if level == "critical"
            else "üü†" if level == "high" else "üü°" if level == "medium" else "üü¢"
        )
        markdown += f"| {emoji} {level.upper()} | {count} |\n"

    markdown += f"| **TOTAL** | **{findings_summary.get('total', 0)}** |\n\n"

    # Detailed Findings
    markdown += "## Detailed Security Findings\n\n"

    detailed_findings = report.get("detailed_findings", [])
    if detailed_findings:
        for finding in detailed_findings[:20]:  # Limit to top 20
            severity = finding.get("severity", "UNKNOWN")
            emoji = (
                "üî¥"
                if severity == "CRITICAL"
                else (
                    "üü†"
                    if severity == "HIGH"
                    else "üü°" if severity == "MEDIUM" else "üü¢"
                )
            )

            markdown += f"### {emoji} [{severity}] {finding.get('vulnerability') or finding.get('attack_type', 'Unknown')}\n\n"
            markdown += f"**URL**: `{finding.get('url', 'N/A')}`  \n"
            markdown += f"**Method**: {finding.get('method', 'N/A')}  \n"

            if finding.get("payload"):
                markdown += f"**Payload**: `{finding.get('payload')}`  \n"

            if finding.get("evidence"):
                markdown += "**Evidence**:  \n"
                evidence = finding.get("evidence")
                if isinstance(evidence, list):
                    for item in evidence:
                        markdown += f"- {item}  \n"
                elif isinstance(evidence, dict):
                    for key, value in evidence.items():
                        markdown += f"- **{key}**: {value}  \n"
                else:
                    markdown += f"- {evidence}  \n"

            if finding.get("impact"):
                markdown += f"**Impact**: {finding.get('impact')}  \n"

            if finding.get("remediation"):
                markdown += f"**Remediation**: {finding.get('remediation')}  \n"

            markdown += "\n---\n\n"

    # Exploitation Summary
    markdown += "## Exploitation Test Results\n\n"

    exploit_details = report.get("exploitation_details", {})
    markdown += (
        f"- **Total Attacks Performed**: {exploit_details.get('total_attacks', 0)}\n"
    )
    markdown += (
        f"- **Successful Exploits**: {exploit_details.get('successful_attacks', 0)}\n"
    )
    markdown += f"- **Success Rate**: {exploit_details.get('success_rate', '0%')}\n\n"

    # Attack Statistics
    attack_stats = report.get("attack_statistics", {})
    if attack_stats:
        markdown += "### Attack Type Breakdown\n\n"
        markdown += "| Attack Type | Attempts |\n"
        markdown += "|-------------|----------|\n"
        for attack_type, count in attack_stats.items():
            clean_type = attack_type.replace("_", " ").title()
            markdown += f"| {clean_type} | {count} |\n"
        markdown += "\n"

    # Confirmed Vulnerabilities
    confirmed = exploit_details.get("confirmed_vulnerabilities", [])
    if confirmed:
        markdown += "### Confirmed Vulnerabilities\n\n"
        for vuln in confirmed:
            markdown += f"- ‚úÖ **{vuln}**\n"
        markdown += "\n"

    # Successful Exploits Details
    successful_exploits = [
        e for e in exploits.get("detailed_exploits", []) if e.get("vulnerable")
    ]
    if successful_exploits:
        markdown += "## Successful Exploit Details\n\n"
        for exploit in successful_exploits:
            markdown += f"### ‚úÖ {exploit.get('type', 'Unknown')}\n\n"
            markdown += f"**URL**: `{exploit.get('url', 'N/A')}`  \n"

            if exploit.get("payload"):
                markdown += f"**Payload**: `{exploit.get('payload')}`  \n"

            if exploit.get("requests_sent"):
                markdown += f"**Requests Sent**: {exploit.get('requests_sent')}  \n"

            if exploit.get("evidence"):
                markdown += "**Evidence**:  \n"
                for item in exploit.get("evidence", []):
                    markdown += f"- {item}  \n"

            markdown += "\n---\n\n"

    # Recommendations
    markdown += "## Security Recommendations\n\n"

    recommendations = report.get("recommendations", {})

    if recommendations.get("immediate"):
        markdown += "### üö® Immediate Actions (Within 24 Hours)\n\n"
        for rec in recommendations["immediate"]:
            markdown += f"1. {rec}\n"
        markdown += "\n"

    if recommendations.get("short_term"):
        markdown += "### ‚ö†Ô∏è Short-term Actions (Within 1 Week)\n\n"
        for rec in recommendations["short_term"]:
            markdown += f"1. {rec}\n"
        markdown += "\n"

    if recommendations.get("long_term"):
        markdown += "### üìã Long-term Actions (Within 1 Month)\n\n"
        for rec in recommendations["long_term"]:
            markdown += f"1. {rec}\n"
        markdown += "\n"

    # Technical Details Summary
    markdown += "## Test Coverage\n\n"
    markdown += f"- **Endpoints Scanned**: {recon.get('endpoints_tested', 0)}\n"
    markdown += (
        f"- **Detailed Results Generated**: {recon.get('detailed_results_count', 0)}\n"
    )
    markdown += f"- **Vulnerabilities Identified**: {vulns.get('total_issues', 0)}\n"
    markdown += f"- **Risk Score**: {vulns.get('risk_score', 0)}/100\n"
    markdown += f"- **Exploits Tested**: {exploits.get('exploits_tested', 0)}\n"
    markdown += f"- **Test Duration**: {duration:.2f} seconds\n\n"

    # Status codes distribution
    status_codes = recon.get("findings", {}).get("status_codes", {})
    if status_codes:
        markdown += "### Response Code Distribution\n\n"
        markdown += "| Status Code | Count | Description |\n"
        markdown += "|-------------|-------|-------------|\n"
        for code, count in sorted(status_codes.items()):
            desc = (
                "OK"
                if code == "200"
                else (
                    "Unauthorized"
                    if code == "401"
                    else (
                        "Not Found"
                        if code == "404"
                        else "Server Error" if code == "500" else "Other"
                    )
                )
            )
            markdown += f"| {code} | {count} | {desc} |\n"
        markdown += "\n"

    # Footer
    markdown += "---\n\n"
    markdown += "*Report generated by Powder Finder Security Assessment Tool*  \n"
    markdown += f"*Timestamp: {datetime.now().isoformat()}*  \n"
    markdown += f"*Target: {target}*\n"

    return markdown


class DetailedPowderFinderReconAgent(BaseAgent):
    """Enhanced reconnaissance agent with detailed endpoint analysis."""

    async def process(self, target: str) -> dict:
        """Scan the powder finder application with detailed logging."""
        print(f"üîç Scanning powder finder application with detailed analysis: {target}")

        findings = {
            "endpoints": [],
            "detailed_endpoints": [],
            "inputs": [],
            "storage": [],
            "auth": [],
            "integrations": [],
            "discovered_apis": [],
            "status_codes": {},
            "headers_analysis": {},
            "cors_config": None,
            "rate_limits": None,
            "detailed_scan_results": [],
        }

        # Real endpoints to test
        test_endpoints = [
            # Health & Monitoring
            "/api/v1/health/",
            "/api/v1/health/detailed",
            "/api/v1/monitoring/weather-collection-status",
            "/api/v1/monitoring/database-stats",
            # Resort Endpoints
            "/api/v1/resorts/",
            "/api/v1/resorts/1",
            "/api/v1/resorts/99999",  # Test invalid ID
            "/api/v1/resorts/search/vail",
            "/api/v1/resorts/search/' OR '1'='1",  # SQL injection test
            "/api/v1/resorts/nearby?lat=39.6403&lon=-106.3742&radius=50",
            # Weather Endpoints
            "/api/v1/weather/current/1",
            "/api/v1/weather/forecast/1",
            # Predictions
            "/api/v1/predictions/",
            "/api/v1/predictions/1",
            # Frontend/Debug
            "/",
            "/dashboard",
            "/debug",
            "/test",
            "/.env",  # Check for exposed env files
            "/.git/config",  # Check for exposed git
            "/admin",  # Check for admin panel
            "/api/docs",
            "/api/openapi.json",
        ]

        # Test actual endpoints with detailed logging
        async with httpx.AsyncClient(timeout=5.0, follow_redirects=False) as client:
            for endpoint in test_endpoints:
                try:
                    url = f"{target}{endpoint}"
                    print(f"  Testing: {endpoint}")

                    # Add custom headers to test for information disclosure
                    headers = {
                        "User-Agent": "PowderFinder-Security-Scanner/1.0",
                        "X-Forwarded-For": "127.0.0.1",
                        "X-Real-IP": "127.0.0.1",
                    }

                    response = await client.get(url, headers=headers)

                    # Detailed endpoint analysis
                    detailed_result = {
                        "url": url,
                        "path": endpoint,
                        "method": "GET",
                        "status_code": response.status_code,
                        "response_size": len(response.content),
                        "response_time_ms": response.elapsed.total_seconds() * 1000,
                        "headers": dict(response.headers),
                        "content_type": response.headers.get("content-type", "unknown"),
                        "security_headers": {
                            "x_frame_options": response.headers.get("x-frame-options"),
                            "x_content_type_options": response.headers.get(
                                "x-content-type-options"
                            ),
                            "x_xss_protection": response.headers.get(
                                "x-xss-protection"
                            ),
                            "strict_transport_security": response.headers.get(
                                "strict-transport-security"
                            ),
                            "content_security_policy": response.headers.get(
                                "content-security-policy"
                            ),
                            "access_control_allow_origin": response.headers.get(
                                "access-control-allow-origin"
                            ),
                        },
                        "interesting_findings": [],
                    }

                    # Check for interesting patterns in response
                    if response.status_code == 200:
                        content_sample = response.text[:500] if response.text else ""

                        # Check for sensitive data exposure
                        if (
                            "api_key" in content_sample.lower()
                            or "secret" in content_sample.lower()
                        ):
                            detailed_result["interesting_findings"].append(
                                "Potential sensitive data in response"
                            )

                        if (
                            "error" in content_sample.lower()
                            and "sql" in content_sample.lower()
                        ):
                            detailed_result["interesting_findings"].append(
                                "SQL error message exposed"
                            )

                        if "debug" in endpoint.lower() or "test" in endpoint.lower():
                            detailed_result["interesting_findings"].append(
                                f"Debug/test endpoint accessible: {endpoint}"
                            )

                        if (
                            endpoint.endswith(".json")
                            or endpoint.endswith(".env")
                            or "/.git/" in endpoint
                        ):
                            detailed_result["interesting_findings"].append(
                                f"Sensitive file exposed: {endpoint}"
                            )

                    # Check for redirect-based issues
                    if 300 <= response.status_code < 400:
                        detailed_result["redirect_location"] = response.headers.get(
                            "location"
                        )
                        detailed_result["interesting_findings"].append(
                            f"Redirect detected to: {response.headers.get('location')}"
                        )

                    # Server information disclosure
                    if response.headers.get("server"):
                        detailed_result["server_info"] = response.headers.get("server")
                        detailed_result["interesting_findings"].append(
                            f"Server header exposes: {response.headers.get('server')}"
                        )

                    findings["detailed_scan_results"].append(detailed_result)

                    # Track status codes
                    status = str(response.status_code)
                    findings["status_codes"][status] = (
                        findings["status_codes"].get(status, 0) + 1
                    )

                    # Store first successful response headers for analysis
                    if response.status_code == 200 and not findings["headers_analysis"]:
                        findings["headers_analysis"] = detailed_result[
                            "security_headers"
                        ]

                    # Check for CORS
                    if response.headers.get("access-control-allow-origin"):
                        findings["cors_config"] = response.headers.get(
                            "access-control-allow-origin"
                        )

                except httpx.TimeoutException:
                    findings["detailed_scan_results"].append(
                        {
                            "url": f"{target}{endpoint}",
                            "path": endpoint,
                            "status": "timeout",
                            "interesting_findings": [
                                "Endpoint timeout - possible DoS vector"
                            ],
                        }
                    )
                except Exception as e:
                    findings["detailed_scan_results"].append(
                        {
                            "url": f"{target}{endpoint}",
                            "path": endpoint,
                            "status": "error",
                            "error_details": str(e),
                            "interesting_findings": [
                                "Connection error - service may be down"
                            ],
                        }
                    )

        # Test POST endpoints with payloads
        post_tests = [
            {
                "endpoint": "/api/v1/weather/update-resort",
                "payload": {"resort_id": 1, "temperature": 999},
                "description": "Test unauthorized weather data modification",
            },
            {
                "endpoint": "/api/v1/chat/",
                "payload": {"message": "<script>alert('XSS')</script>"},
                "description": "Test XSS in chat endpoint",
            },
            {
                "endpoint": "/api/v1/chat/resort-recommendations",
                "payload": {"preferences": "' OR '1'='1' --"},
                "description": "Test SQL injection in preferences",
            },
        ]

        async with httpx.AsyncClient(timeout=5.0) as client:
            for test in post_tests:
                try:
                    url = f"{target}{test['endpoint']}"
                    print(f"  Testing POST: {test['endpoint']} - {test['description']}")

                    response = await client.post(url, json=test["payload"])

                    detailed_result = {
                        "url": url,
                        "path": test["endpoint"],
                        "method": "POST",
                        "payload": test["payload"],
                        "description": test["description"],
                        "status_code": response.status_code,
                        "response_size": len(response.content),
                        "interesting_findings": [],
                    }

                    # Check if payload was reflected (XSS)
                    if (
                        "<script>" in str(test["payload"])
                        and "<script>" in response.text
                    ):
                        detailed_result["interesting_findings"].append(
                            "XSS payload reflected in response!"
                        )
                        detailed_result["vulnerability_confirmed"] = True

                    # Check for SQL errors
                    if (
                        "sql" in response.text.lower()
                        and "error" in response.text.lower()
                    ):
                        detailed_result["interesting_findings"].append(
                            "SQL error in response - possible injection"
                        )
                        detailed_result["vulnerability_confirmed"] = True

                    # Check if modification was successful without auth
                    if response.status_code in [200, 201]:
                        detailed_result["interesting_findings"].append(
                            "POST succeeded without authentication!"
                        )
                        detailed_result["vulnerability_confirmed"] = True

                    findings["detailed_scan_results"].append(detailed_result)

                except Exception as e:
                    findings["detailed_scan_results"].append(
                        {
                            "url": f"{target}{test['endpoint']}",
                            "path": test["endpoint"],
                            "method": "POST",
                            "payload": test["payload"],
                            "error": str(e),
                        }
                    )

        return {
            "agent": "recon",
            "target": target,
            "findings": findings,
            "timestamp": datetime.now().isoformat(),
            "endpoints_tested": len(test_endpoints) + len(post_tests),
            "detailed_results_count": len(findings["detailed_scan_results"]),
        }


class DetailedPowderFinderVulnAnalyzer(BaseAgent):
    """Enhanced vulnerability analyzer with detailed findings."""

    async def process(self, recon_data: dict) -> dict:
        """Analyze vulnerabilities with detailed evidence."""
        print("üî¨ Analyzing vulnerabilities with detailed evidence...")

        vulnerabilities = {
            "critical": [],
            "high": [],
            "medium": [],
            "low": [],
            "detailed_vulnerabilities": [],
        }

        detailed_scan = recon_data.get("detailed_scan_results", [])

        # Analyze each endpoint for vulnerabilities
        for result in detailed_scan:
            if not isinstance(result, dict):
                continue

            path = result.get("path", "")
            status = result.get("status_code", 0)
            findings = result.get("interesting_findings", [])

            # Check for authentication issues
            if result.get("method") == "POST" and status in [200, 201]:
                vuln = {
                    "type": "Authentication Bypass",
                    "severity": "critical",
                    "url": result.get("url"),
                    "method": result.get("method"),
                    "evidence": {
                        "payload": result.get("payload"),
                        "response_code": status,
                        "description": "POST request succeeded without authentication",
                    },
                    "impact": "Unauthorized data modification",
                    "remediation": "Implement proper authentication and authorization",
                }
                vulnerabilities["critical"].append(f"No authentication on {path}")
                vulnerabilities["detailed_vulnerabilities"].append(vuln)

            # Check for SQL injection
            if "sql" in path.lower() and "'" in path:
                if status == 500 or any(
                    "sql" in f.lower() and "error" in f.lower() for f in findings
                ):
                    vuln = {
                        "type": "SQL Injection",
                        "severity": "critical",
                        "url": result.get("url"),
                        "method": "GET",
                        "evidence": {
                            "payload": path,
                            "response_code": status,
                            "error_exposed": "SQL error" in str(findings),
                        },
                        "impact": "Database compromise, data theft",
                        "remediation": "Use parameterized queries",
                    }
                    vulnerabilities["critical"].append(f"SQL injection in {path}")
                    vulnerabilities["detailed_vulnerabilities"].append(vuln)

            # Check for XSS
            if result.get("vulnerability_confirmed") and "<script>" in str(
                result.get("payload", "")
            ):
                vuln = {
                    "type": "Cross-Site Scripting (XSS)",
                    "severity": "high",
                    "url": result.get("url"),
                    "method": result.get("method"),
                    "evidence": {
                        "payload": result.get("payload"),
                        "reflected": True,
                        "description": "XSS payload reflected without sanitization",
                    },
                    "impact": "Session hijacking, account takeover",
                    "remediation": "Sanitize and encode all user input",
                }
                vulnerabilities["high"].append(f"XSS vulnerability in {path}")
                vulnerabilities["detailed_vulnerabilities"].append(vuln)

            # Check for exposed debug endpoints
            if ("/debug" in path or "/test" in path) and status == 200:
                vuln = {
                    "type": "Information Disclosure",
                    "severity": "high",
                    "url": result.get("url"),
                    "method": "GET",
                    "evidence": {
                        "endpoint": path,
                        "status_code": status,
                        "description": "Debug/test endpoint exposed in production",
                    },
                    "impact": "Information leakage, attack surface increase",
                    "remediation": "Remove or protect debug endpoints",
                }
                vulnerabilities["high"].append(f"Debug endpoint exposed: {path}")
                vulnerabilities["detailed_vulnerabilities"].append(vuln)

            # Check for sensitive file exposure
            if path in ["/.env", "/.git/config", "/api/openapi.json"] and status == 200:
                vuln = {
                    "type": "Sensitive File Exposure",
                    "severity": "critical",
                    "url": result.get("url"),
                    "method": "GET",
                    "evidence": {
                        "file": path,
                        "status_code": status,
                        "size": result.get("response_size", 0),
                    },
                    "impact": "Credentials exposure, source code leak",
                    "remediation": "Block access to sensitive files",
                }
                vulnerabilities["critical"].append(f"Sensitive file exposed: {path}")
                vulnerabilities["detailed_vulnerabilities"].append(vuln)

            # Check for IDOR
            if "/resorts/99999" in path and status != 404:
                vuln = {
                    "type": "Insecure Direct Object Reference (IDOR)",
                    "severity": "medium",
                    "url": result.get("url"),
                    "method": "GET",
                    "evidence": {
                        "test_id": "99999",
                        "response_code": status,
                        "description": "Invalid ID doesn't return 404",
                    },
                    "impact": "Unauthorized data access via ID enumeration",
                    "remediation": "Implement proper access controls and use UUIDs",
                }
                vulnerabilities["medium"].append("IDOR vulnerability in resort IDs")
                vulnerabilities["detailed_vulnerabilities"].append(vuln)

            # Check for missing security headers
            security_headers = result.get("security_headers", {})
            if security_headers and not security_headers.get("x_frame_options"):
                if "Missing X-Frame-Options" not in str(vulnerabilities["medium"]):
                    vuln = {
                        "type": "Missing Security Headers",
                        "severity": "medium",
                        "url": result.get("url"),
                        "evidence": {
                            "missing_headers": [
                                h for h, v in security_headers.items() if not v
                            ]
                        },
                        "impact": "Clickjacking, XSS, MITM attacks",
                        "remediation": "Implement security headers",
                    }
                    vulnerabilities["medium"].append("Missing security headers")
                    vulnerabilities["detailed_vulnerabilities"].append(vuln)

        # Calculate risk score
        risk_score = (
            len(vulnerabilities["critical"]) * 40
            + len(vulnerabilities["high"]) * 25
            + len(vulnerabilities["medium"]) * 15
            + len(vulnerabilities["low"]) * 5
        )

        return {
            "agent": "vulnerability_analyzer",
            "vulnerabilities": vulnerabilities,
            "risk_score": min(100, risk_score),
            "timestamp": datetime.now().isoformat(),
            "total_issues": sum(
                len(v)
                for k, v in vulnerabilities.items()
                if k != "detailed_vulnerabilities"
            ),
            "detailed_findings_count": len(vulnerabilities["detailed_vulnerabilities"]),
        }


class DetailedPowderFinderExploitTester(BaseAgent):
    """Enhanced exploit tester with detailed attack logs."""

    async def process(self, vulnerabilities: dict) -> dict:
        """Test exploits with detailed logging."""
        print("üí• Testing exploits with detailed logging...")

        exploits = {}
        detailed_exploits = []
        target = "http://localhost"

        # Test actual exploits with detailed logging
        async with httpx.AsyncClient(timeout=5.0) as client:

            # SQL Injection Tests
            print("  Testing SQL injection attacks...")
            sql_payloads = [
                ("vail' OR '1'='1", "Basic OR injection"),
                ("vail'; DROP TABLE users--", "Drop table attempt"),
                (
                    "vail' UNION SELECT * FROM information_schema.tables--",
                    "Schema enumeration",
                ),
                ("vail' AND 1=1--", "Boolean-based blind"),
                ("vail' AND SLEEP(5)--", "Time-based blind"),
            ]

            for payload, description in sql_payloads:
                try:
                    url = f"{target}/api/v1/resorts/search/{payload}"
                    response = await client.get(url)

                    exploit_detail = {
                        "type": "SQL Injection",
                        "url": url,
                        "payload": payload,
                        "description": description,
                        "response_code": response.status_code,
                        "response_size": len(response.content),
                        "response_time_ms": response.elapsed.total_seconds() * 1000,
                        "vulnerable": False,
                        "evidence": [],
                    }

                    # Check for SQL errors
                    if response.status_code == 500:
                        exploit_detail["vulnerable"] = True
                        exploit_detail["evidence"].append(
                            "500 error indicates SQL syntax issue"
                        )

                    if (
                        "sql" in response.text.lower()
                        and "error" in response.text.lower()
                    ):
                        exploit_detail["vulnerable"] = True
                        exploit_detail["evidence"].append(
                            "SQL error message in response"
                        )

                    # Check for successful injection
                    if response.status_code == 200 and "OR '1'='1" in payload:
                        # Check if we got more results than expected
                        exploit_detail["evidence"].append(
                            "Query succeeded with OR injection"
                        )

                    detailed_exploits.append(exploit_detail)

                    if exploit_detail["vulnerable"]:
                        exploits["sql_injection"] = exploit_detail
                        break  # Found vulnerable, no need to test more

                except Exception as e:
                    detailed_exploits.append(
                        {
                            "type": "SQL Injection",
                            "url": url,
                            "payload": payload,
                            "error": str(e),
                        }
                    )

            # IDOR Tests
            print("  Testing IDOR vulnerabilities...")
            idor_tests = [
                ("1", "Valid ID test"),
                ("99999", "Non-existent ID test"),
                ("0", "Zero ID test"),
                ("-1", "Negative ID test"),
                ("1 OR 1=1", "SQL in ID parameter"),
                ("../../../etc/passwd", "Path traversal in ID"),
            ]

            for test_id, description in idor_tests:
                try:
                    url = f"{target}/api/v1/resorts/{test_id}"
                    response = await client.get(url)

                    exploit_detail = {
                        "type": "IDOR",
                        "url": url,
                        "test_id": test_id,
                        "description": description,
                        "response_code": response.status_code,
                        "response_size": len(response.content),
                        "vulnerable": False,
                        "evidence": [],
                    }

                    # Check for IDOR issues
                    if test_id in ["99999", "0", "-1"] and response.status_code == 200:
                        exploit_detail["vulnerable"] = True
                        exploit_detail["evidence"].append(
                            f"Invalid ID {test_id} returned data"
                        )

                    if test_id in ["99999", "0", "-1"] and response.status_code != 404:
                        exploit_detail["evidence"].append(
                            "Invalid ID didn't return 404"
                        )

                    detailed_exploits.append(exploit_detail)

                except Exception as e:
                    detailed_exploits.append(
                        {
                            "type": "IDOR",
                            "url": url,
                            "test_id": test_id,
                            "error": str(e),
                        }
                    )

            # XSS Tests
            print("  Testing XSS vulnerabilities...")
            xss_payloads = [
                ("<script>alert('XSS')</script>", "Basic script injection"),
                ("<img src=x onerror=alert('XSS')>", "Image tag injection"),
                ("javascript:alert('XSS')", "JavaScript protocol"),
                ("<svg onload=alert('XSS')>", "SVG injection"),
                ("'><script>alert('XSS')</script>", "Quote breaking injection"),
            ]

            for payload, description in xss_payloads:
                try:
                    url = f"{target}/api/v1/chat/"
                    response = await client.post(url, json={"message": payload})

                    exploit_detail = {
                        "type": "XSS",
                        "url": url,
                        "payload": payload,
                        "description": description,
                        "method": "POST",
                        "response_code": response.status_code,
                        "vulnerable": False,
                        "evidence": [],
                    }

                    # Check if payload is reflected
                    if payload in response.text:
                        exploit_detail["vulnerable"] = True
                        exploit_detail["evidence"].append(
                            "Payload reflected without encoding"
                        )

                    if "<script>" in payload and "<script>" in response.text:
                        exploit_detail["vulnerable"] = True
                        exploit_detail["evidence"].append("Script tags not filtered")

                    detailed_exploits.append(exploit_detail)

                    if exploit_detail["vulnerable"]:
                        exploits["xss"] = exploit_detail
                        break

                except Exception as e:
                    detailed_exploits.append(
                        {"type": "XSS", "url": url, "payload": payload, "error": str(e)}
                    )

            # Rate Limiting Test
            print("  Testing rate limiting...")
            rate_limit_test = {
                "type": "Rate Limiting",
                "url": f"{target}/api/v1/health/",
                "requests_sent": 0,
                "rate_limit_hit": False,
                "response_codes": [],
                "vulnerable": False,
                "evidence": [],
            }

            for i in range(50):  # Test with 50 requests
                try:
                    response = await client.get(rate_limit_test["url"])
                    rate_limit_test["requests_sent"] += 1
                    rate_limit_test["response_codes"].append(response.status_code)

                    if response.status_code == 429:
                        rate_limit_test["rate_limit_hit"] = True
                        rate_limit_test["evidence"].append(
                            f"Rate limit hit after {i+1} requests"
                        )
                        break

                except Exception as e:
                    rate_limit_test["evidence"].append(
                        f"Error after {i+1} requests: {str(e)}"
                    )
                    break

            if (
                not rate_limit_test["rate_limit_hit"]
                and rate_limit_test["requests_sent"] >= 50
            ):
                rate_limit_test["vulnerable"] = True
                rate_limit_test["evidence"].append(
                    f"No rate limit after {rate_limit_test['requests_sent']} requests"
                )

            detailed_exploits.append(rate_limit_test)
            exploits["rate_limiting"] = rate_limit_test

            # Authentication Bypass Test
            print("  Testing authentication bypass...")
            auth_tests = [
                {
                    "url": f"{target}/api/v1/weather/update-resort",
                    "method": "POST",
                    "payload": {
                        "resort_id": 1,
                        "temperature": 999,
                        "conditions": "hacked",
                    },
                    "description": "Modify weather without auth",
                },
                {
                    "url": f"{target}/api/v1/predictions/",
                    "method": "POST",
                    "payload": {"resort_id": 1, "prediction": "compromised"},
                    "description": "Create prediction without auth",
                },
            ]

            for test in auth_tests:
                try:
                    response = await client.post(test["url"], json=test["payload"])

                    exploit_detail = {
                        "type": "Authentication Bypass",
                        "url": test["url"],
                        "method": test["method"],
                        "payload": test["payload"],
                        "description": test["description"],
                        "response_code": response.status_code,
                        "vulnerable": False,
                        "evidence": [],
                    }

                    if response.status_code in [200, 201]:
                        exploit_detail["vulnerable"] = True
                        exploit_detail["evidence"].append(
                            "POST succeeded without authentication"
                        )

                    if response.status_code != 401 and response.status_code != 403:
                        exploit_detail["evidence"].append(
                            f"No auth challenge (got {response.status_code})"
                        )

                    detailed_exploits.append(exploit_detail)

                    if exploit_detail["vulnerable"]:
                        exploits["auth_bypass"] = exploit_detail

                except Exception as e:
                    detailed_exploits.append(
                        {
                            "type": "Authentication Bypass",
                            "url": test["url"],
                            "error": str(e),
                        }
                    )

        # Calculate success metrics
        successful_exploits = sum(
            1 for e in detailed_exploits if isinstance(e, dict) and e.get("vulnerable")
        )
        total_exploits = len(detailed_exploits)
        success_rate = (
            (successful_exploits / total_exploits * 100) if total_exploits > 0 else 0
        )

        return {
            "agent": "exploit_tester",
            "exploits": exploits,
            "detailed_exploits": detailed_exploits,
            "success_rate": f"{success_rate:.1f}%",
            "timestamp": datetime.now().isoformat(),
            "exploits_tested": total_exploits,
            "successful_exploits": successful_exploits,
            "attack_summary": {
                "sql_injection_attempts": len(
                    [e for e in detailed_exploits if e.get("type") == "SQL Injection"]
                ),
                "xss_attempts": len(
                    [e for e in detailed_exploits if e.get("type") == "XSS"]
                ),
                "idor_attempts": len(
                    [e for e in detailed_exploits if e.get("type") == "IDOR"]
                ),
                "auth_bypass_attempts": len(
                    [
                        e
                        for e in detailed_exploits
                        if e.get("type") == "Authentication Bypass"
                    ]
                ),
            },
        }


class DetailedPowderFinderReportGenerator(BaseAgent):
    """Generate comprehensive security report with full details."""

    async def process(self, test_results: dict) -> dict:
        """Generate detailed security report."""
        print("üìä Generating detailed security report...")

        # Extract data
        recon = test_results.get("recon", {})
        vulns = test_results.get("vulnerabilities", {})
        exploits = test_results.get("exploits", {})

        # Build detailed report
        detailed_findings = []

        # Add vulnerability details
        for vuln in vulns.get("vulnerabilities", {}).get(
            "detailed_vulnerabilities", []
        ):
            detailed_findings.append(
                {
                    "finding_type": "Vulnerability",
                    "severity": vuln.get("severity", "unknown").upper(),
                    "vulnerability": vuln.get("type"),
                    "url": vuln.get("url"),
                    "method": vuln.get("method", "GET"),
                    "evidence": vuln.get("evidence"),
                    "impact": vuln.get("impact"),
                    "remediation": vuln.get("remediation"),
                }
            )

        # Add exploit details
        for exploit in exploits.get("detailed_exploits", []):
            if exploit.get("vulnerable"):
                detailed_findings.append(
                    {
                        "finding_type": "Confirmed Exploit",
                        "severity": "CRITICAL",
                        "attack_type": exploit.get("type"),
                        "url": exploit.get("url"),
                        "payload": exploit.get("payload") or exploit.get("test_id"),
                        "description": exploit.get("description"),
                        "evidence": exploit.get("evidence"),
                        "response_code": exploit.get("response_code"),
                    }
                )

        # Sort findings by severity
        severity_order = {"CRITICAL": 0, "HIGH": 1, "MEDIUM": 2, "LOW": 3}
        detailed_findings.sort(
            key=lambda x: severity_order.get(x.get("severity", "LOW"), 4)
        )

        # Build executive summary
        vuln_data = vulns.get("vulnerabilities", {})
        findings_summary = {
            "critical": len(vuln_data.get("critical", [])),
            "high": len(vuln_data.get("high", [])),
            "medium": len(vuln_data.get("medium", [])),
            "low": len(vuln_data.get("low", [])),
            "total": sum(
                len(v) for k, v in vuln_data.items() if k != "detailed_vulnerabilities"
            ),
        }

        report = {
            "executive_summary": f"""
                Security assessment of {recon.get('target')} identified {findings_summary['total']} vulnerabilities.
                {findings_summary['critical']} CRITICAL and {findings_summary['high']} HIGH severity issues require immediate attention.

                Attack testing revealed {exploits.get('successful_exploits', 0)} successful exploits out of {exploits.get('exploits_tested', 0)} attempts.
                Success rate: {exploits.get('success_rate', '0%')}
            """,
            "risk_level": (
                "CRITICAL"
                if findings_summary["critical"] > 0
                else "HIGH" if findings_summary["high"] > 0 else "MEDIUM"
            ),
            "findings_summary": findings_summary,
            "detailed_findings": detailed_findings,
            "attack_statistics": exploits.get("attack_summary", {}),
            "tested_endpoints": recon.get("endpoints_tested", 0),
            "exploitation_details": {
                "total_attacks": exploits.get("exploits_tested", 0),
                "successful_attacks": exploits.get("successful_exploits", 0),
                "success_rate": exploits.get("success_rate", "0%"),
                "confirmed_vulnerabilities": [
                    e.get("type")
                    for e in exploits.get("detailed_exploits", [])
                    if e.get("vulnerable")
                ],
            },
            "technical_details": {
                "scan_timestamp": recon.get("timestamp"),
                "endpoints_scanned": recon.get("endpoints_tested", 0),
                "detailed_results": recon.get("findings", {}).get(
                    "detailed_scan_results", []
                ),
            },
            "recommendations": {
                "immediate": [
                    "Fix all CRITICAL vulnerabilities within 24 hours",
                    "Implement authentication on all API endpoints",
                    "Deploy Web Application Firewall (WAF)",
                ],
                "short_term": [
                    "Add rate limiting to all endpoints",
                    "Implement security headers",
                    "Fix SQL injection vulnerabilities",
                ],
                "long_term": [
                    "Conduct regular security audits",
                    "Implement secure development lifecycle",
                    "Deploy intrusion detection system",
                ],
            },
        }

        return {
            "agent": "report_generator",
            "report": report,
            "timestamp": datetime.now().isoformat(),
            "total_findings": len(detailed_findings),
        }


async def run_detailed_powder_finder_pentest():
    """Run the detailed powder finder penetration test."""

    print("\n" + "=" * 60)
    print("DETAILED POWDER FINDER SECURITY ASSESSMENT")
    print("=" * 60 + "\n")

    target = "http://localhost"

    print(f"Target: {target}")
    print("Mode: Detailed attack analysis")
    print()

    # Create mock publisher
    publisher = ResultPublisher()
    publisher.redis = AsyncMock()
    publisher._connected = True

    # Configure mock Redis
    stored_results = {}

    async def mock_get(key):
        return stored_results.get(key)

    async def mock_setex(key, ttl, value):
        stored_results[key] = value
        return True

    publisher.redis.get = AsyncMock(side_effect=mock_get)
    publisher.redis.setex = AsyncMock(side_effect=mock_setex)
    publisher.redis.sadd = AsyncMock(return_value=1)
    publisher.redis.zadd = AsyncMock(return_value=1)
    publisher.redis.expire = AsyncMock(return_value=True)
    publisher.redis.smembers = AsyncMock(return_value=[])
    publisher.redis.zrevrange = AsyncMock(return_value=[])

    # Memory strategy
    standard_memory = MemoryStrategy(
        short_term_size=100,
        long_term_size=1000,
        short_term_ttl=3600,
        long_term_ttl=86400,
    )

    # Create agents
    print("Initializing detailed penetration test agents...")

    agents = {
        "recon": DetailedPowderFinderReconAgent(
            agent_id="detailed_recon",
            memory_strategy=standard_memory,
        ),
        "vuln_analyzer": DetailedPowderFinderVulnAnalyzer(
            agent_id="detailed_vuln",
            memory_strategy=standard_memory,
        ),
        "exploit_tester": DetailedPowderFinderExploitTester(
            agent_id="detailed_exploit",
            memory_strategy=standard_memory,
        ),
        "reporter": DetailedPowderFinderReportGenerator(
            agent_id="detailed_reporter",
            memory_strategy=standard_memory,
        ),
    }

    # Mock memory for all agents
    for agent in agents.values():
        agent.memory = AsyncMock()

    print(f"‚úì Initialized {len(agents)} specialized agents\n")

    results = {}
    start_time = datetime.now()

    try:
        # Phase 1: Reconnaissance
        print("=" * 50)
        print("PHASE 1: DETAILED RECONNAISSANCE")
        print("=" * 50)
        recon_result = await agents["recon"].process(target)
        results["recon"] = recon_result
        print(f"‚úì Scanned {recon_result.get('endpoints_tested', 0)} endpoints")
        print(
            f"‚úì Generated {recon_result.get('detailed_results_count', 0)} detailed reports\n"
        )

        # Phase 2: Vulnerability Analysis
        print("=" * 50)
        print("PHASE 2: DETAILED VULNERABILITY ANALYSIS")
        print("=" * 50)
        vuln_result = await agents["vuln_analyzer"].process(recon_result["findings"])
        results["vulnerabilities"] = vuln_result
        print(f"‚úì Identified {vuln_result.get('total_issues', 0)} vulnerabilities")
        print(f"‚úì Risk score: {vuln_result.get('risk_score', 0)}/100")
        print(f"‚úì Detailed findings: {vuln_result.get('detailed_findings_count', 0)}\n")

        # Phase 3: Exploit Testing
        print("=" * 50)
        print("PHASE 3: DETAILED EXPLOIT TESTING")
        print("=" * 50)
        exploit_result = await agents["exploit_tester"].process(
            vuln_result["vulnerabilities"]
        )
        results["exploits"] = exploit_result
        print(f"‚úì Tested {exploit_result.get('exploits_tested', 0)} exploits")
        print(f"‚úì Successful: {exploit_result.get('successful_exploits', 0)}")
        print(f"‚úì Success rate: {exploit_result.get('success_rate', '0%')}\n")

        # Phase 4: Report Generation
        print("=" * 50)
        print("PHASE 4: DETAILED REPORT GENERATION")
        print("=" * 50)
        report_result = await agents["reporter"].process(results)
        results["report"] = report_result
        print(
            f"‚úì Generated report with {report_result.get('total_findings', 0)} detailed findings\n"
        )

        # Calculate performance
        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()

        # Save results
        results_dir = "pentest-results"
        os.makedirs(results_dir, exist_ok=True)

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        result_file = f"{results_dir}/detailed_powder_finder_pentest_{timestamp}.json"
        markdown_file = f"{results_dir}/detailed_powder_finder_pentest_{timestamp}.md"

        with open(result_file, "w") as f:
            json.dump(results, f, indent=2, default=str)

        # Generate Markdown Report
        markdown_report = generate_markdown_report(results, target, duration)
        with open(markdown_file, "w") as f:
            f.write(markdown_report)

        print(f"‚úì JSON results saved to: {result_file}")
        print(f"‚úì Markdown report saved to: {markdown_file}\n")

        # Display detailed report
        report = report_result["report"]

        print("=" * 60)
        print("DETAILED SECURITY ASSESSMENT REPORT")
        print("=" * 60 + "\n")

        print("EXECUTIVE SUMMARY:")
        print("-" * 40)
        print(report["executive_summary"])

        print("\n\nDETAILED FINDINGS:")
        print("-" * 40)

        for finding in report["detailed_findings"][:10]:  # Show top 10
            print(
                f"\n[{finding['severity']}] {finding.get('vulnerability') or finding.get('attack_type')}"
            )
            print(f"  URL: {finding.get('url')}")
            print(f"  Method: {finding.get('method', 'GET')}")

            if finding.get("payload"):
                print(f"  Payload: {finding['payload']}")

            if finding.get("evidence"):
                print(f"  Evidence: {finding['evidence']}")

            if finding.get("impact"):
                print(f"  Impact: {finding['impact']}")

            if finding.get("remediation"):
                print(f"  Fix: {finding['remediation']}")

        if len(report["detailed_findings"]) > 10:
            print(f"\n... and {len(report['detailed_findings']) - 10} more findings")

        print("\n\nATTACK STATISTICS:")
        print("-" * 40)
        for attack_type, count in report["attack_statistics"].items():
            print(f"  {attack_type}: {count}")

        print("\n\nEXPLOITATION SUMMARY:")
        print("-" * 40)
        print(f"  Total Attacks: {report['exploitation_details']['total_attacks']}")
        print(f"  Successful: {report['exploitation_details']['successful_attacks']}")
        print(f"  Success Rate: {report['exploitation_details']['success_rate']}")

        if report["exploitation_details"]["confirmed_vulnerabilities"]:
            print("\n  Confirmed Vulnerabilities:")
            for vuln in report["exploitation_details"]["confirmed_vulnerabilities"]:
                print(f"    ‚Ä¢ {vuln}")

        print("\n" + "=" * 60)
        print(f"Test completed in {duration:.2f} seconds")
        print("=" * 60)

    except Exception as e:
        print(f"\n‚ùå Error: {e}")
        import traceback

        traceback.print_exc()


if __name__ == "__main__":
    print("\n" + "=" * 60)
    print("DETAILED PENETRATION TEST LAUNCHER")
    print("=" * 60)

    print("\n‚ö†Ô∏è  This test will perform detailed security analysis")
    print("Make sure your application is running on http://localhost\n")

    asyncio.run(run_detailed_powder_finder_pentest())
