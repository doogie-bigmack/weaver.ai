"""Specialized penetration testing agents for security assessment."""

from __future__ import annotations

import asyncio
import random
import string
from datetime import datetime
from typing import Any
from urllib.parse import quote, urljoin

import aiohttp


class BaseTestAgent:
    """Base class for all penetration testing agents."""

    def __init__(self, target_url: str):
        self.target_url = target_url.rstrip("/")
        self.session: aiohttp.ClientSession | None = None
        self.findings: list[dict[str, Any]] = []

    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()

    def add_finding(
        self,
        title: str,
        severity: str,
        description: str,
        endpoint: str = "",
        evidence: Any = None,
        remediation: str = "",
    ):
        """Add a security finding."""
        self.findings.append(
            {
                "title": title,
                "severity": severity,
                "description": description,
                "endpoint": endpoint,
                "evidence": evidence,
                "remediation": remediation,
                "timestamp": datetime.utcnow().isoformat(),
            }
        )


class ReconAgent(BaseTestAgent):
    """Agent for reconnaissance and discovery."""

    async def execute(self, api_key: str | None = None) -> dict[str, Any]:
        """Perform reconnaissance on target."""
        async with self:
            results = {
                "endpoints": [],
                "api_endpoints": [],
                "monitoring_endpoints": [],
                "static_resources": [],
                "server_info": {},
                "discovered_params": [],
            }

            # Test base endpoints
            base_endpoints = [
                "/",
                "/dashboard",
                "/dashboard-enhanced",
                "/debug",
                "/test",
                "/working-dashboard",
                "/404",
                "/api/docs",
                "/api/redoc",
                "/api/openapi.json",
            ]

            for endpoint in base_endpoints:
                url = urljoin(self.target_url, endpoint)
                try:
                    async with self.session.get(url, timeout=5) as resp:
                        results["endpoints"].append(
                            {
                                "url": url,
                                "status": resp.status,
                                "headers": dict(resp.headers),
                                "accessible": resp.status < 400,
                            }
                        )

                        # Check for server info leakage
                        if "Server" in resp.headers:
                            results["server_info"]["server"] = resp.headers["Server"]
                        if "X-Powered-By" in resp.headers:
                            results["server_info"]["powered_by"] = resp.headers[
                                "X-Powered-By"
                            ]

                except Exception as e:
                    results["endpoints"].append(
                        {"url": url, "error": str(e), "accessible": False}
                    )

            # Discover API endpoints
            api_endpoints = [
                "/api/v1/health/",
                "/api/v1/health/detailed",
                "/api/v1/resorts/",
                "/api/v1/resorts/with-weather",
                "/api/v1/weather/current/1",
                "/api/v1/predictions/",
                "/api/v1/monitoring/database-stats",
                "/api/v1/system/status",
            ]

            headers = {}
            if api_key:
                headers["X-API-Key"] = api_key

            for endpoint in api_endpoints:
                url = urljoin(self.target_url, endpoint)
                try:
                    async with self.session.get(
                        url, headers=headers, timeout=5
                    ) as resp:
                        results["api_endpoints"].append(
                            {
                                "url": url,
                                "status": resp.status,
                                "requires_auth": resp.status == 401,
                                "accessible": resp.status < 400,
                            }
                        )

                        if "/monitoring/" in endpoint or "/health/" in endpoint:
                            results["monitoring_endpoints"].append(url)

                except Exception as e:
                    results["api_endpoints"].append({"url": url, "error": str(e)})

            # Check for static resources
            static_paths = [
                "/static/",
                "/static/css/",
                "/static/js/",
                "/static/images/",
            ]

            for path in static_paths:
                url = urljoin(self.target_url, path)
                try:
                    async with self.session.get(url, timeout=5) as resp:
                        if resp.status < 400:
                            results["static_resources"].append(
                                {
                                    "url": url,
                                    "status": resp.status,
                                    "directory_listing": "Index of" in await resp.text()
                                    or "<title>Directory" in await resp.text(),
                                }
                            )
                except:
                    pass

            return results


class VulnScanAgent(BaseTestAgent):
    """Agent for vulnerability scanning."""

    async def execute(
        self, endpoints: list[Any], api_key: str | None = None
    ) -> dict[str, Any]:
        """Scan for common vulnerabilities."""
        async with self:
            results = {"issues": [], "scanned_endpoints": 0}

            headers = {}
            if api_key:
                headers["X-API-Key"] = api_key

            # Test for common vulnerabilities
            vuln_tests = [
                # Path traversal
                ("/../../../etc/passwd", "Path Traversal"),
                ("/api/v1/resorts/../../admin", "Path Traversal"),
                # Information disclosure
                ("/.git/", "Git Repository Exposure"),
                ("/.env", "Environment File Exposure"),
                ("/backup.sql", "Database Backup Exposure"),
                ("/phpinfo.php", "PHP Info Disclosure"),
                # Debug endpoints
                ("/debug", "Debug Endpoint Exposed"),
                ("/test", "Test Endpoint Exposed"),
            ]

            for path, vuln_type in vuln_tests:
                url = urljoin(self.target_url, path)
                try:
                    async with self.session.get(
                        url, headers=headers, timeout=5
                    ) as resp:
                        if resp.status == 200:
                            content = await resp.text()
                            # Check for actual vulnerability indicators
                            if vuln_type == "Path Traversal" and "root:" in content:
                                self.add_finding(
                                    title=f"{vuln_type} Vulnerability",
                                    severity="critical",
                                    description=f"Path traversal vulnerability found at {url}",
                                    endpoint=url,
                                    evidence={
                                        "status": resp.status,
                                        "snippet": content[:200],
                                    },
                                    remediation="Implement proper path validation and sanitization",
                                )
                            elif vuln_type == "Git Repository Exposure" and (
                                "refs/heads" in content or "objects/" in content
                            ):
                                self.add_finding(
                                    title="Git Repository Exposed",
                                    severity="high",
                                    description="Git repository is publicly accessible",
                                    endpoint=url,
                                    evidence={"status": resp.status},
                                    remediation="Remove .git directory from public access",
                                )
                            elif (
                                vuln_type
                                in ["Debug Endpoint Exposed", "Test Endpoint Exposed"]
                                and resp.status == 200
                            ):
                                self.add_finding(
                                    title=vuln_type,
                                    severity="medium",
                                    description="Development/debug endpoint is accessible in production",
                                    endpoint=url,
                                    evidence={"status": resp.status},
                                    remediation="Remove or restrict access to debug endpoints in production",
                                )
                except:
                    pass

            results["scanned_endpoints"] = len(vuln_tests)
            results["issues"] = self.findings
            return results


class AuthTestAgent(BaseTestAgent):
    """Agent for testing authentication and authorization."""

    async def execute(
        self, endpoints: list[Any], api_key: str | None = None
    ) -> dict[str, Any]:
        """Test authentication mechanisms."""
        async with self:
            results = {"issues": [], "tests_performed": []}

            # Test without API key
            test_endpoints = [
                "/api/v1/resorts/",
                "/api/v1/weather/current/1",
                "/api/v1/predictions/",
                "/api/v1/monitoring/database-stats",
            ]

            for endpoint in test_endpoints:
                url = urljoin(self.target_url, endpoint)

                # Test 1: No authentication
                try:
                    async with self.session.get(url, timeout=5) as resp:
                        if resp.status == 200:
                            self.add_finding(
                                title="Missing Authentication",
                                severity="high",
                                description="API endpoint accessible without authentication",
                                endpoint=url,
                                evidence={"status": resp.status},
                                remediation="Implement API key validation for all API endpoints",
                            )
                        results["tests_performed"].append(
                            {"test": "no_auth", "endpoint": url, "result": resp.status}
                        )
                except:
                    pass

                # Test 2: Invalid API key
                try:
                    headers = {
                        "X-API-Key": "invalid_"
                        + "".join(random.choices(string.ascii_letters, k=20))
                    }
                    async with self.session.get(
                        url, headers=headers, timeout=5
                    ) as resp:
                        if resp.status == 200:
                            self.add_finding(
                                title="Weak API Key Validation",
                                severity="high",
                                description="API accepts invalid API keys",
                                endpoint=url,
                                evidence={
                                    "status": resp.status,
                                    "api_key": headers["X-API-Key"],
                                },
                                remediation="Implement proper API key validation",
                            )
                        results["tests_performed"].append(
                            {
                                "test": "invalid_key",
                                "endpoint": url,
                                "result": resp.status,
                            }
                        )
                except:
                    pass

                # Test 3: Empty API key
                try:
                    headers = {"X-API-Key": ""}
                    async with self.session.get(
                        url, headers=headers, timeout=5
                    ) as resp:
                        if resp.status == 200:
                            self.add_finding(
                                title="Empty API Key Accepted",
                                severity="high",
                                description="API accepts empty API key values",
                                endpoint=url,
                                evidence={"status": resp.status},
                                remediation="Validate API key is not empty",
                            )
                except:
                    pass

                # Test 4: SQL injection in API key
                try:
                    headers = {"X-API-Key": "' OR '1'='1"}
                    async with self.session.get(
                        url, headers=headers, timeout=5
                    ) as resp:
                        if resp.status == 200:
                            self.add_finding(
                                title="SQL Injection in API Key",
                                severity="critical",
                                description="API key field vulnerable to SQL injection",
                                endpoint=url,
                                evidence={
                                    "status": resp.status,
                                    "payload": headers["X-API-Key"],
                                },
                                remediation="Use parameterized queries for API key validation",
                            )
                except:
                    pass

            results["issues"] = self.findings
            return results


class InjectionTestAgent(BaseTestAgent):
    """Agent for testing injection vulnerabilities."""

    async def execute(
        self, endpoints: list[Any], api_key: str | None = None
    ) -> dict[str, Any]:
        """Test for injection vulnerabilities."""
        async with self:
            results = {"issues": [], "tests_performed": []}

            headers = {}
            if api_key:
                headers["X-API-Key"] = api_key

            # SQL injection payloads
            sql_payloads = [
                "' OR '1'='1",
                "1' AND '1'='2",
                "'; DROP TABLE users; --",
                "1 UNION SELECT * FROM users",
                "' OR 1=1--",
                "admin'--",
                "1' ORDER BY 1--",
                "1' UNION SELECT NULL--",
            ]

            # NoSQL injection payloads
            nosql_payloads = [
                '{"$ne": null}',
                '{"$gt": ""}',
                '{"$regex": ".*"}',
            ]

            # XSS payloads
            xss_payloads = [
                "<script>alert('XSS')</script>",
                "javascript:alert('XSS')",
                "<img src=x onerror=alert('XSS')>",
                "';alert('XSS');//",
                "<svg onload=alert('XSS')>",
            ]

            # Command injection payloads
            cmd_payloads = [
                "; ls -la",
                "| whoami",
                "& ping -c 1 127.0.0.1",
                "`id`",
                "$(whoami)",
            ]

            # Test search endpoint
            search_endpoint = "/api/v1/resorts/search/"
            for payload in sql_payloads:
                url = urljoin(self.target_url, search_endpoint + quote(payload))
                try:
                    async with self.session.get(
                        url, headers=headers, timeout=5
                    ) as resp:
                        content = await resp.text()
                        # Check for SQL error messages
                        sql_errors = [
                            "SQL",
                            "mysql",
                            "sqlite",
                            "postgresql",
                            "ORA-",
                            "syntax error",
                        ]
                        if any(
                            error.lower() in content.lower() for error in sql_errors
                        ):
                            self.add_finding(
                                title="SQL Injection",
                                severity="critical",
                                description="SQL injection vulnerability in search parameter",
                                endpoint=url,
                                evidence={
                                    "payload": payload,
                                    "response_snippet": content[:500],
                                },
                                remediation="Use parameterized queries and input validation",
                            )
                        results["tests_performed"].append(
                            {
                                "type": "sql_injection",
                                "endpoint": url,
                                "payload": payload,
                                "status": resp.status,
                            }
                        )
                except:
                    pass

            # Test chat endpoint for injection
            chat_endpoint = "/api/v1/chat/"
            for payload in xss_payloads:
                try:
                    data = {"message": payload}
                    async with self.session.post(
                        urljoin(self.target_url, chat_endpoint),
                        json=data,
                        headers={**headers, "Content-Type": "application/json"},
                        timeout=5,
                    ) as resp:
                        if resp.status == 200:
                            content = await resp.text()
                            if (
                                payload in content
                                or payload.replace("<", "&lt;") not in content
                            ):
                                self.add_finding(
                                    title="XSS Vulnerability",
                                    severity="high",
                                    description="Cross-site scripting vulnerability in chat endpoint",
                                    endpoint=chat_endpoint,
                                    evidence={"payload": payload},
                                    remediation="Implement proper output encoding and Content Security Policy",
                                )
                except:
                    pass

            # Test weather update endpoint for command injection
            weather_endpoint = "/api/v1/weather/update-resort"
            for payload in cmd_payloads:
                try:
                    data = {"resort_id": payload}
                    async with self.session.post(
                        urljoin(self.target_url, weather_endpoint),
                        json=data,
                        headers={**headers, "Content-Type": "application/json"},
                        timeout=5,
                    ) as resp:
                        content = await resp.text()
                        # Check for command execution indicators
                        if any(
                            indicator in content
                            for indicator in ["uid=", "root", "bin/", "etc/"]
                        ):
                            self.add_finding(
                                title="Command Injection",
                                severity="critical",
                                description="Command injection vulnerability in weather update",
                                endpoint=weather_endpoint,
                                evidence={"payload": payload},
                                remediation="Sanitize input and avoid shell command execution",
                            )
                except:
                    pass

            results["issues"] = self.findings
            return results


class RateLimitTestAgent(BaseTestAgent):
    """Agent for testing rate limiting."""

    async def execute(
        self, endpoints: list[Any], api_key: str | None = None
    ) -> dict[str, Any]:
        """Test rate limiting implementation."""
        async with self:
            results = {"issues": [], "tests_performed": []}

            headers = {}
            if api_key:
                headers["X-API-Key"] = api_key

            test_endpoints = [
                "/api/v1/resorts/",
                "/api/v1/weather/current/1",
                "/api/v1/chat/",
            ]

            for endpoint in test_endpoints:
                url = urljoin(self.target_url, endpoint)

                # Send rapid requests
                request_count = 100
                success_count = 0
                rate_limited = False

                for i in range(request_count):
                    try:
                        if endpoint == "/api/v1/chat/":
                            async with self.session.post(
                                url,
                                json={"message": f"test {i}"},
                                headers={**headers, "Content-Type": "application/json"},
                                timeout=2,
                            ) as resp:
                                if resp.status == 200:
                                    success_count += 1
                                elif resp.status == 429:
                                    rate_limited = True
                                    break
                        else:
                            async with self.session.get(
                                url, headers=headers, timeout=2
                            ) as resp:
                                if resp.status == 200:
                                    success_count += 1
                                elif resp.status == 429:
                                    rate_limited = True
                                    break
                    except:
                        pass

                    # Small delay to avoid connection issues
                    if i % 10 == 0:
                        await asyncio.sleep(0.1)

                results["tests_performed"].append(
                    {
                        "endpoint": url,
                        "requests_sent": i + 1,
                        "successful_requests": success_count,
                        "rate_limited": rate_limited,
                    }
                )

                if success_count >= 50 and not rate_limited:
                    self.add_finding(
                        title="Missing Rate Limiting",
                        severity="medium",
                        description=f"No rate limiting detected on {endpoint}",
                        endpoint=url,
                        evidence={
                            "requests_sent": i + 1,
                            "successful_requests": success_count,
                        },
                        remediation="Implement rate limiting to prevent abuse",
                    )

            results["issues"] = self.findings
            return results


class DataExposureAgent(BaseTestAgent):
    """Agent for testing data exposure vulnerabilities."""

    async def execute(
        self, endpoints: list[Any], api_key: str | None = None
    ) -> dict[str, Any]:
        """Test for sensitive data exposure."""
        async with self:
            results = {"issues": [], "sensitive_data_found": []}

            headers = {}
            if api_key:
                headers["X-API-Key"] = api_key

            # Endpoints likely to expose sensitive data
            sensitive_endpoints = [
                "/api/v1/health/detailed",
                "/api/v1/monitoring/database-stats",
                "/api/v1/system/status",
                "/debug",
                "/api/openapi.json",
            ]

            # Patterns indicating sensitive data
            sensitive_patterns = [
                "password",
                "secret",
                "token",
                "api_key",
                "apikey",
                "private_key",
                "privatekey",
                "access_key",
                "accesskey",
                "database",
                "mongodb://",
                "postgresql://",
                "mysql://",
                "redis://",
                "amqp://",
                "connection_string",
                "aws_access_key",
                "aws_secret",
                "stripe",
                "paypal",
                "email",
                "phone",
                "ssn",
                "credit_card",
            ]

            for endpoint in sensitive_endpoints:
                url = urljoin(self.target_url, endpoint)
                try:
                    async with self.session.get(
                        url, headers=headers, timeout=5
                    ) as resp:
                        if resp.status == 200:
                            content = await resp.text()
                            content_lower = content.lower()

                            # Check for sensitive patterns
                            found_patterns = []
                            for pattern in sensitive_patterns:
                                if pattern in content_lower:
                                    found_patterns.append(pattern)

                            if found_patterns:
                                self.add_finding(
                                    title="Sensitive Data Exposure",
                                    severity=(
                                        "high"
                                        if any(
                                            p
                                            in [
                                                "password",
                                                "secret",
                                                "token",
                                                "api_key",
                                            ]
                                            for p in found_patterns
                                        )
                                        else "medium"
                                    ),
                                    description=f"Potential sensitive data exposed in {endpoint}",
                                    endpoint=url,
                                    evidence={
                                        "patterns_found": found_patterns,
                                        "sample": (
                                            content[:500]
                                            if len(content) > 500
                                            else content
                                        ),
                                    },
                                    remediation="Remove or redact sensitive information from public endpoints",
                                )
                                results["sensitive_data_found"].append(
                                    {"endpoint": url, "patterns": found_patterns}
                                )

                            # Check for stack traces
                            if (
                                "traceback" in content_lower
                                or "exception" in content_lower
                                or "error" in content_lower
                            ):
                                self.add_finding(
                                    title="Stack Trace Exposure",
                                    severity="medium",
                                    description="Stack trace or error details exposed",
                                    endpoint=url,
                                    evidence={"snippet": content[:500]},
                                    remediation="Implement proper error handling and avoid exposing internal errors",
                                )

                            # Check for version information
                            version_indicators = [
                                "version",
                                "v1.",
                                "v2.",
                                "build",
                                "release",
                            ]
                            if any(ind in content_lower for ind in version_indicators):
                                results["sensitive_data_found"].append(
                                    {"endpoint": url, "type": "version_info"}
                                )
                except:
                    pass

            # Test for directory traversal in static resources
            traversal_tests = [
                "/static/../../../etc/passwd",
                "/static/css/../../../../../../etc/passwd",
                "/static/%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            ]

            for path in traversal_tests:
                url = urljoin(self.target_url, path)
                try:
                    async with self.session.get(url, timeout=5) as resp:
                        if resp.status == 200:
                            content = await resp.text()
                            if "root:" in content or "/bin/bash" in content:
                                self.add_finding(
                                    title="Directory Traversal in Static Files",
                                    severity="critical",
                                    description="Directory traversal vulnerability in static file serving",
                                    endpoint=url,
                                    evidence={"status": resp.status},
                                    remediation="Implement proper path sanitization for static file serving",
                                )
                except:
                    pass

            results["issues"] = self.findings
            return results


class ReportGeneratorAgent(BaseTestAgent):
    """Agent for generating penetration test reports."""

    async def generate(self, test_results: dict[str, Any]) -> dict[str, Any]:
        """Generate comprehensive penetration test report."""
        report = {
            "executive_summary": self._generate_executive_summary(test_results),
            "technical_details": test_results["findings"],
            "severity_breakdown": test_results["severity_summary"],
            "recommendations": self._generate_recommendations(test_results),
            "timestamp": test_results["timestamp"],
            "target": test_results["target"],
        }

        # Generate HTML report
        report["html"] = self._generate_html_report(report)

        return report

    def _generate_executive_summary(self, results: dict[str, Any]) -> str:
        """Generate executive summary of findings."""
        total_issues = sum(results["severity_summary"].values())
        critical = results["severity_summary"]["critical"]
        high = results["severity_summary"]["high"]

        summary = f"""
Penetration Test Executive Summary
===================================

Target: {results['target']}
Test Date: {results['timestamp']}

Total Issues Found: {total_issues}
- Critical: {critical}
- High: {high}
- Medium: {results['severity_summary']['medium']}
- Low: {results['severity_summary']['low']}
- Informational: {results['severity_summary']['info']}

"""

        if critical > 0:
            summary += "⚠️ CRITICAL ISSUES FOUND - Immediate action required!\n\n"
        elif high > 0:
            summary += (
                "⚠️ High severity issues found - Prompt remediation recommended.\n\n"
            )
        else:
            summary += "✓ No critical or high severity issues found.\n\n"

        return summary

    def _generate_recommendations(self, results: dict[str, Any]) -> list[str]:
        """Generate prioritized recommendations."""
        recommendations = []

        # Analyze findings and generate recommendations
        for category, findings in results["findings"].items():
            if isinstance(findings, dict) and "issues" in findings:
                for issue in findings["issues"]:
                    if issue["severity"] in ["critical", "high"]:
                        if issue["remediation"]:
                            recommendations.append(
                                {
                                    "priority": (
                                        "high"
                                        if issue["severity"] == "critical"
                                        else "medium"
                                    ),
                                    "category": category,
                                    "recommendation": issue["remediation"],
                                    "related_finding": issue["title"],
                                }
                            )

        # Sort by priority
        recommendations.sort(key=lambda x: 0 if x["priority"] == "high" else 1)

        return recommendations

    def _generate_html_report(self, report: dict[str, Any]) -> str:
        """Generate HTML version of the report."""
        html = f"""
<!DOCTYPE html>
<html>
<head>
    <title>Penetration Test Report - {report['target']}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 40px; }}
        h1 {{ color: #333; }}
        .critical {{ color: #d32f2f; font-weight: bold; }}
        .high {{ color: #f57c00; font-weight: bold; }}
        .medium {{ color: #fbc02d; }}
        .low {{ color: #388e3c; }}
        .info {{ color: #1976d2; }}
        table {{ border-collapse: collapse; width: 100%; margin: 20px 0; }}
        th, td {{ border: 1px solid #ddd; padding: 12px; text-align: left; }}
        th {{ background-color: #f2f2f2; }}
        .summary-box {{ background: #f5f5f5; padding: 20px; border-radius: 5px; margin: 20px 0; }}
    </style>
</head>
<body>
    <h1>Penetration Test Report</h1>
    <div class="summary-box">
        <h2>Executive Summary</h2>
        <pre>{report['executive_summary']}</pre>
    </div>

    <h2>Severity Breakdown</h2>
    <table>
        <tr>
            <th>Severity</th>
            <th>Count</th>
        </tr>
        <tr class="critical">
            <td>Critical</td>
            <td>{report['severity_breakdown']['critical']}</td>
        </tr>
        <tr class="high">
            <td>High</td>
            <td>{report['severity_breakdown']['high']}</td>
        </tr>
        <tr class="medium">
            <td>Medium</td>
            <td>{report['severity_breakdown']['medium']}</td>
        </tr>
        <tr class="low">
            <td>Low</td>
            <td>{report['severity_breakdown']['low']}</td>
        </tr>
        <tr class="info">
            <td>Informational</td>
            <td>{report['severity_breakdown']['info']}</td>
        </tr>
    </table>

    <h2>Recommendations</h2>
    <ol>
        {''.join(f"<li><strong>{r['related_finding']}</strong>: {r['recommendation']}</li>" for r in report['recommendations'])}
    </ol>

    <hr>
    <p><small>Generated: {report['timestamp']}</small></p>
</body>
</html>
"""
        return html
