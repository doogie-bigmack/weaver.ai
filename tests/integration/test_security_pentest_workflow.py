"""Multi-agent security penetration testing workflow.

This demonstrates a complete security pen testing workflow with multiple
specialized agents sharing results through the ResultPublisher.
"""

import asyncio
from typing import Any

import pytest
import pytest_asyncio
import redis.asyncio as redis

from weaver_ai.agents import BaseAgent, ResultPublisher
from weaver_ai.memory import MemoryStrategy


class ReconAgent(BaseAgent):
    """Reconnaissance agent for initial target discovery."""

    agent_type: str = "recon"
    capabilities: list[str] = ["security.recon", "network.scan"]

    async def scan_target(
        self, target: str, publisher: ResultPublisher
    ) -> dict[str, Any]:
        """Perform reconnaissance on target."""
        # Simulate reconnaissance
        recon_data = {
            "target": target,
            "open_ports": [22, 80, 443, 3306],
            "services": {
                "22": "SSH",
                "80": "HTTP",
                "443": "HTTPS",
                "3306": "MySQL",
            },
            "technologies": ["nginx", "PHP", "MySQL", "WordPress"],
            "subdomains": ["www", "api", "admin", "blog"],
            "ssl_info": {
                "issuer": "Let's Encrypt",
                "expiry": "2024-06-01",
                "grade": "A",
            },
        }

        # Memory storage would go here in production

        # Publish result
        result = await publisher.publish(
            agent_id=self.agent_id,
            data=recon_data,
            capabilities_required=["security.read"],
            workflow_id="pentest",
            tags={"phase": "reconnaissance", "target": target},
        )

        return {"result_id": result.metadata.result_id, "data": recon_data}


class VulnerabilityScanner(BaseAgent):
    """Agent for vulnerability scanning."""

    agent_type: str = "vuln_scanner"
    capabilities: list[str] = ["security.scan", "security.read"]

    async def scan_vulnerabilities(
        self,
        recon_result_id: str,
        publisher: ResultPublisher,
    ) -> dict[str, Any]:
        """Scan for vulnerabilities based on recon data."""
        # Retrieve recon results
        recon_result = await publisher.retrieve(
            recon_result_id,
            agent_capabilities=self.capabilities,
        )

        if not recon_result:
            return {"error": "Cannot access recon results"}

        recon_data = recon_result.data

        # Simulate vulnerability scanning
        vulnerabilities = []

        # Check for common vulnerabilities
        if 22 in recon_data.get("open_ports", []):
            vulnerabilities.append(
                {
                    "service": "SSH",
                    "port": 22,
                    "vulnerability": "Weak SSH configuration",
                    "severity": "medium",
                    "cve": "CVE-2023-1234",
                    "description": "SSH allows password authentication",
                    "recommendation": "Disable password auth, use key-based only",
                }
            )

        if "WordPress" in recon_data.get("technologies", []):
            vulnerabilities.append(
                {
                    "service": "WordPress",
                    "port": 80,
                    "vulnerability": "Outdated WordPress version",
                    "severity": "high",
                    "cve": "CVE-2023-5678",
                    "description": "WordPress 5.x vulnerable to SQL injection",
                    "recommendation": "Update to latest WordPress version",
                }
            )

        if 3306 in recon_data.get("open_ports", []):
            vulnerabilities.append(
                {
                    "service": "MySQL",
                    "port": 3306,
                    "vulnerability": "MySQL exposed to internet",
                    "severity": "critical",
                    "cve": "N/A",
                    "description": "Database port publicly accessible",
                    "recommendation": "Restrict MySQL to localhost only",
                }
            )

        vuln_data = {
            "target": recon_data.get("target"),
            "vulnerabilities": vulnerabilities,
            "total_found": len(vulnerabilities),
            "critical": sum(1 for v in vulnerabilities if v["severity"] == "critical"),
            "high": sum(1 for v in vulnerabilities if v["severity"] == "high"),
            "medium": sum(1 for v in vulnerabilities if v["severity"] == "medium"),
            "scan_type": "automated",
        }

        # Memory storage would go here in production

        # Publish result
        result = await publisher.publish(
            agent_id=self.agent_id,
            data=vuln_data,
            capabilities_required=["security.read", "security.exploit"],
            workflow_id="pentest",
            parent_result_id=recon_result_id,
            tags={"phase": "vulnerability_scan"},
        )

        return {"result_id": result.metadata.result_id, "data": vuln_data}


class ExploitAgent(BaseAgent):
    """Agent for testing exploits (safely)."""

    agent_type: str = "exploit"
    capabilities: list[str] = ["security.exploit", "security.read"]

    async def test_exploits(
        self,
        vuln_result_id: str,
        publisher: ResultPublisher,
    ) -> dict[str, Any]:
        """Test exploits for discovered vulnerabilities."""
        # Retrieve vulnerability results
        vuln_result = await publisher.retrieve(
            vuln_result_id,
            agent_capabilities=self.capabilities,
        )

        if not vuln_result:
            return {"error": "Cannot access vulnerability results"}

        vuln_data = vuln_result.data
        exploits_tested = []

        # Test exploits for each vulnerability
        for vuln in vuln_data.get("vulnerabilities", []):
            if vuln["severity"] in ["critical", "high"]:
                exploit_test = {
                    "vulnerability": vuln["vulnerability"],
                    "exploit_attempted": True,
                    "success": False,  # Always false for safety
                    "impact": "Simulated - no actual exploit performed",
                    "proof_of_concept": f"Would attempt {vuln['cve']} exploit",
                    "mitigation_tested": True,
                }
                exploits_tested.append(exploit_test)

        exploit_data = {
            "target": vuln_data.get("target"),
            "exploits_tested": exploits_tested,
            "total_tested": len(exploits_tested),
            "successful": 0,  # Always 0 for safety
            "recommendations": [
                "Apply all critical patches immediately",
                "Implement Web Application Firewall",
                "Enable intrusion detection system",
                "Regular security updates and monitoring",
            ],
        }

        # Publish result
        result = await publisher.publish(
            agent_id=self.agent_id,
            data=exploit_data,
            capabilities_required=["security.read", "security.report"],
            workflow_id="pentest",
            parent_result_id=vuln_result_id,
            tags={"phase": "exploitation"},
        )

        return {"result_id": result.metadata.result_id, "data": exploit_data}


class ReportingAgent(BaseAgent):
    """Agent for generating security reports."""

    agent_type: str = "reporter"
    capabilities: list[str] = ["security.report", "security.read"]

    async def generate_report(
        self,
        workflow_id: str,
        publisher: ResultPublisher,
    ) -> dict[str, Any]:
        """Generate comprehensive security report."""
        # Get all workflow results
        results = await publisher.list_by_workflow(workflow_id)

        if not results:
            return {"error": "No results found for workflow"}

        # Retrieve all result data
        recon_data = None
        vuln_data = None
        exploit_data = None

        for metadata in results:
            result = await publisher.retrieve(
                metadata.result_id,
                agent_capabilities=self.capabilities,
            )
            if result:
                if metadata.agent_id.startswith("recon"):
                    recon_data = result.data
                elif metadata.agent_id.startswith("vuln"):
                    vuln_data = result.data
                elif metadata.agent_id.startswith("exploit"):
                    exploit_data = result.data

        # Generate report
        report = {
            "executive_summary": {
                "target": recon_data.get("target") if recon_data else "Unknown",
                "test_date": "2024-01-01",
                "overall_risk": "HIGH",
                "vulnerabilities_found": (
                    vuln_data.get("total_found", 0) if vuln_data else 0
                ),
                "critical_issues": vuln_data.get("critical", 0) if vuln_data else 0,
            },
            "findings": {
                "reconnaissance": recon_data if recon_data else {},
                "vulnerabilities": vuln_data if vuln_data else {},
                "exploitation": exploit_data if exploit_data else {},
            },
            "recommendations": {
                "immediate": [
                    "Patch critical vulnerabilities",
                    "Restrict database access",
                    "Update WordPress",
                ],
                "short_term": [
                    "Implement WAF",
                    "Enable IDS/IPS",
                    "Security training for staff",
                ],
                "long_term": [
                    "Regular security audits",
                    "Implement DevSecOps",
                    "Zero-trust architecture",
                ],
            },
            "compliance": {
                "pci_dss": "Non-compliant",
                "gdpr": "Partial compliance",
                "iso_27001": "Major gaps identified",
            },
        }

        # Publish final report
        result = await publisher.publish(
            agent_id=self.agent_id,
            data=report,
            capabilities_required=["security.read"],
            workflow_id=workflow_id,
            tags={"phase": "reporting", "type": "final_report"},
        )

        return {"result_id": result.metadata.result_id, "report": report}


class PenTestOrchestrator:
    """Orchestrates the multi-agent pen testing workflow."""

    def __init__(self, publisher: ResultPublisher):
        self.publisher = publisher
        self.agents: dict[str, BaseAgent] = {}

    async def setup_agents(self):
        """Initialize all agents."""
        # Create memory strategy for security agents
        security_memory = MemoryStrategy(
            short_term_size=1000,
            long_term_size=10000,
            short_term_ttl=7200,  # 2 hours
            long_term_ttl=86400,  # 24 hours
        )

        # Initialize agents
        self.agents["recon"] = ReconAgent(
            agent_id="recon_agent_001",
            memory_strategy=security_memory,
        )
        await self.agents["recon"].initialize()

        self.agents["vuln_scanner"] = VulnerabilityScanner(
            agent_id="vuln_scanner_001",
            memory_strategy=security_memory,
        )
        await self.agents["vuln_scanner"].initialize()

        self.agents["exploit"] = ExploitAgent(
            agent_id="exploit_agent_001",
            memory_strategy=security_memory,
        )
        await self.agents["exploit"].initialize()

        self.agents["reporter"] = ReportingAgent(
            agent_id="reporter_agent_001",
            memory_strategy=security_memory,
        )
        await self.agents["reporter"].initialize()

    async def run_pentest(self, target: str) -> dict[str, Any]:
        """Run complete penetration test workflow."""
        results = {}

        # Phase 1: Reconnaissance
        print(f"[*] Starting reconnaissance on {target}...")
        recon_result = await self.agents["recon"].scan_target(target, self.publisher)
        results["recon"] = recon_result
        print(
            f"[+] Recon complete: {len(recon_result['data']['open_ports'])} ports found"
        )

        # Phase 2: Vulnerability Scanning
        print("[*] Scanning for vulnerabilities...")
        vuln_result = await self.agents["vuln_scanner"].scan_vulnerabilities(
            recon_result["result_id"],
            self.publisher,
        )
        results["vulnerabilities"] = vuln_result
        print(
            f"[+] Vuln scan complete: {vuln_result['data']['total_found']} vulnerabilities found"
        )

        # Phase 3: Exploit Testing
        print("[*] Testing exploits (safely)...")
        exploit_result = await self.agents["exploit"].test_exploits(
            vuln_result["result_id"],
            self.publisher,
        )
        results["exploits"] = exploit_result
        print(
            f"[+] Exploit testing complete: {len(exploit_result['data']['exploits_tested'])} tested"
        )

        # Phase 4: Report Generation
        print("[*] Generating report...")
        report_result = await self.agents["reporter"].generate_report(
            "pentest",
            self.publisher,
        )
        results["report"] = report_result
        print("[+] Report generated successfully")

        # Get lineage to show workflow
        lineage = await self.publisher.get_lineage(recon_result["result_id"])
        results["workflow_lineage"] = [
            {"agent": r.agent_id, "timestamp": r.timestamp} for r in lineage
        ]

        return results


@pytest_asyncio.fixture
async def redis_client():
    """Create a Redis client for testing."""
    client = await redis.from_url("redis://localhost:6379", db=15)
    yield client
    await client.flushdb()
    await client.close()


@pytest_asyncio.fixture
async def publisher(redis_client):
    """Create a ResultPublisher for testing."""
    pub = ResultPublisher(redis_client=redis_client, namespace="pentest")
    yield pub
    await pub.disconnect()


@pytest.mark.asyncio
async def test_security_pentest_workflow(publisher):
    """Test complete security pen testing workflow."""
    # Create orchestrator
    orchestrator = PenTestOrchestrator(publisher)
    await orchestrator.setup_agents()

    # Run pen test
    results = await orchestrator.run_pentest("example.com")

    # Verify all phases completed
    assert "recon" in results
    assert "vulnerabilities" in results
    assert "exploits" in results
    assert "report" in results

    # Verify recon found ports and services
    recon_data = results["recon"]["data"]
    assert len(recon_data["open_ports"]) > 0
    assert len(recon_data["services"]) > 0
    assert len(recon_data["technologies"]) > 0

    # Verify vulnerabilities were discovered
    vuln_data = results["vulnerabilities"]["data"]
    assert vuln_data["total_found"] > 0
    assert len(vuln_data["vulnerabilities"]) > 0

    # Verify exploits were tested
    exploit_data = results["exploits"]["data"]
    assert len(exploit_data["exploits_tested"]) > 0
    assert exploit_data["successful"] == 0  # Safety check

    # Verify report was generated
    report = results["report"]["report"]
    assert "executive_summary" in report
    assert "findings" in report
    assert "recommendations" in report
    assert report["executive_summary"]["vulnerabilities_found"] > 0

    # Verify workflow lineage
    assert len(results["workflow_lineage"]) >= 4  # At least 4 agents

    # Verify results are accessible through publisher
    workflow_results = await publisher.list_by_workflow("pentest")
    assert len(workflow_results) >= 4

    # Verify access control works
    # Try to access without proper capabilities
    restricted_result = await publisher.retrieve(
        results["exploits"]["result_id"],
        agent_capabilities=["basic.read"],  # Wrong capability
    )
    assert restricted_result is None  # Should be denied

    # Access with correct capabilities
    authorized_result = await publisher.retrieve(
        results["exploits"]["result_id"],
        agent_capabilities=["security.read"],
    )
    assert authorized_result is not None


@pytest.mark.asyncio
async def test_parallel_pentests(publisher):
    """Test running multiple pen tests in parallel."""
    # Create multiple orchestrators
    orchestrators = [PenTestOrchestrator(publisher) for _ in range(3)]

    # Setup agents for each
    for orch in orchestrators:
        await orch.setup_agents()

    # Run pen tests in parallel on different targets
    targets = ["site1.com", "site2.com", "site3.com"]
    tasks = [
        orch.run_pentest(target)
        for orch, target in zip(orchestrators, targets, strict=False)
    ]

    results = await asyncio.gather(*tasks)

    # Verify all completed
    assert len(results) == 3
    for i, result in enumerate(results):
        assert result["recon"]["data"]["target"] == targets[i]
        assert "report" in result


if __name__ == "__main__":
    # Run the workflow manually
    async def main():
        # Setup
        redis_client = await redis.from_url("redis://localhost:6379", db=15)
        publisher = ResultPublisher(redis_client=redis_client, namespace="pentest_demo")

        try:
            # Run pen test
            orchestrator = PenTestOrchestrator(publisher)
            await orchestrator.setup_agents()

            print("\n" + "=" * 60)
            print("SECURITY PENETRATION TESTING WORKFLOW DEMO")
            print("=" * 60 + "\n")

            results = await orchestrator.run_pentest("demo.example.com")

            print("\n" + "=" * 60)
            print("WORKFLOW COMPLETE")
            print("=" * 60)

            # Print summary
            report = results["report"]["report"]
            print("\nEXECUTIVE SUMMARY:")
            print(f"  Target: {report['executive_summary']['target']}")
            print(f"  Risk Level: {report['executive_summary']['overall_risk']}")
            print(
                f"  Vulnerabilities: {report['executive_summary']['vulnerabilities_found']}"
            )
            print(
                f"  Critical Issues: {report['executive_summary']['critical_issues']}"
            )

            print("\nWORKFLOW LINEAGE:")
            for step in results["workflow_lineage"]:
                print(f"  - {step['agent']}")

        finally:
            # Cleanup
            await redis_client.flushdb()
            await redis_client.close()
            await publisher.disconnect()

    # Run the demo
    asyncio.run(main())
